---
title: "OSTEP - 가상화: 멀티 레벨 피드백 큐"
lang: "ko"
layout: post
date: 2021-08-21 23:50:42 +0900
categories: [os,]
tags: [os,]
---

이전 라운드 로빈(RR)과 같은 알고리즘이 산출하는 응답 시간은 짧지만, 반환 시간은 거의 최악이었다. 그렇다면 짧은 응답 시간과 반환 시간을 모두 가능하게 할 수 있는 알고리즘은 없는 것일까? 다행히도 **멀티 레벨 피드백 큐(Multi-level Feedback Queue, MLFQ)**라는 스케줄링 기법이 존재한다. MLFQ는 반환 시간과 응답 시간을 모두 최적화하며, 짧게 실행되는 대화형 작업에 대해서는 (SJF/STCF와 유사하게) 우수한 성능을 제공하고, 오래 실행되는 CPU-집중 워크로드에 대해서는 공정한 실행을 보장한다. 이러한 우수한 성능으로 많은 시스템들이 MLFQ를 기본 스케줄러로 채택하고 있다.

MLFQ는 기본적으로 여러 개의 **큐**로 구성되며, 각각 다른 **우선 순위(priority level)**가 배정된다. MLFQ는 높은 우선 순위를 가진 작업을 높은 우선 순위 큐에 배정하여 선택 실행한다. 하나의 큐에 둘 이상의 작업이 존재할 수 있는데, 이는 해당 작업들이 모두 같은 우선 순위를 가짐을 의미한다. 이 작업들 사이에서는 RR 스케줄링 알고리즘이 사용된다.

MLFQ 스케줄링의 핵심은, MLFQ가 우선 순위를 지정하는 방식에서, 각 작업에 고정된 우선 순위를 부여하는 것이 아니라, 각 작업의 _특성에 따라_ 동적으로 우선 순위를 부여한다는 점이다. 예를 들어, 반복적인 입출력으로 CPU를 양도하는 대화형 패턴의 작업은 우선 순위를 높게 유지하지만, 긴 시간 동안 CPU를 집중적으로 사용하는 작업은 우선 순위를 낮춘다. 이렇듯 MLFQ는 작업이 진행되는 동안 해당 작업의 정보를 얻고, _해당 정보_ 를 이용하여 _미래_ 행동을 예측한다.

```sh             
[High Priority] Q8 -> A -> B
                Q7          
                Q6          
                Q5          
                Q4 -> C     
                Q3          
                Q2          
[Low Priority]  Q1 -> D

(MLFQ의 예시)
```

MLFQ를 좀 더 명확히 살펴보기 위해 다음과 같이 규칙을 설정해볼 수 있다:

- 규칙 1: Priority(A) > Priority(B) 이면, A가 실행된다 (B는 실행되지 않는다).
- 규칙 2: Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다.
- 규칙 3: 작업이 시스템에 진입하면, 가장 높은 우선 순위, 즉 맨 위의 큐에 놓여진다.
- 규칙 4a: 주어진 타임 슬라이스를 모두 사용하면 우선순위는 _낮아진다_. 즉, 한 단계 아래 큐로 이동한다.
- 규칙 4b: 타임 슬라이스를 소진하기 전에 CPU를 양도하면 _같은_ 우선순위를 유지한다.

해당 규칙을 가진 MLFQ에 긴 실행 시간을 가진 작업이 들어오게 된다면, 먼저 최고 우선 순위로 진입한 뒤, 설정된 타임 슬라이스를 하나 지나면 스케줄러는 작업의 우선 순위를 한 단계 낮출 것이다. 그렇게 가장 낮은 우선순위로 작업이 이동한 뒤, 이후에는 가장 낮은 우선 순위 큐에서 작업이 유지될 것이다.

```sh
    ++                               
    ||                               
    ||                               
    ||                               
Q2  ++++-----------------------------
      ||                             
      ||                             
      ||                             
Q1  --+++---------------------------+
        |                           |
        |                           |
        |                           |
Q0  ----+---------------------------+
    0        50        100        150

(긴 실행 시간을 가진 작업의 우선 순위 변화)
```

만약 중간에 대화형 작업과 같은 짧은 작업이 들어오게 될 경우, 스케줄러는 해당 작업을 우선 짧은 작업이라고 가정하여 높은 우선 순위를 부여한 후, 우선 순위에 따라 작업을 실행할 것이다. 이는 SFJ와 근사한 모습을 보여준다.

```sh
                +-+                
                | |                
                +-+                
                                    
Q2  -----------------+-+-------------
                     | |             
                     +-+             
                                    
Q1  +------------+-----+------------+
    |            |     |            |
    |            |     |            |
    |            |     |            |
Q0  +------------+-----+------------+
    200        250        300        

(대화형 작업이 들어온 경우)
```

만약 대화형 작업이 타임 슬라이스가 종료되기 전에 반복하여 CPU를 양도한다면, 해당 작업은 동일한 우선 순위를 유지할 수 있을 것이다.

```sh
    +  +  +  +  +  +  +  +  +  +  +  
    |  |  |  |  |  |  |  |  |  |  |  
    |  |  |  |  |  |  |  |  |  |  |  
    |  |  |  |  |  |  |  |  |  |  |  
Q2  +--+--+--+--+--+--+--+--+--+--+--
                                    
                                    
                                    
Q1  -++-++-++-++-++-++-++-++-++-++-++
    || || || || || || || || || || ||
    || || || || || || || || || || ||
    || || || || || || || || || || ||
Q0  -++-++-++-++-++-++-++-++-++-++-++
    0        50        100        150

(입출력-집중 작업과 CPU-집중 작업이 혼합된 워크로드)
```

하지만, MLFQ에 이러한 규칙을 그대로 적용하면, 만약 시스템에 너무 많은 대화형 작업이 들어올 경우, 그 작업들이 모든 CPU 시간을 소모하게 될 것이고, 긴 실행 시간 작업은 CPU 시간을 할당 받지 못하는 **기아 상태(starvation)**가 발생할 수 있다. 또한 사용자가 임의적으로 타임 슬라이스가 끝나기 전에 아무 파일을 대상으로 입출력 요청을 하여 CPU를 양도함으로써, CPU를 독점하는 악용 문제에 취약하다.

이를 위한 간단한 아이디어로, 주기적으로 모든 작업의 우선 순위를 **상향 조정(boost)** 하는 방법이 있다. 즉, 새로운 규칙을 추가한다면:

- 규칙 5: 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

이 규칙으로 인해 프로세스의 기아 문제를 방지할 수도 있고, CPU 위주의 작업이 대화형 위주의 작업으로 특성이 변할 경우에도, 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용할 수 있다.

```sh
                                      
             Boost      Boost  ++  ++|
               |          |  ++++++++|
     +-+       +-+        +-+++  ++  |
     | |       | |        | |        |
 Q2  +-+-------+-+--------+-+--------|
               |          |          |
       +-+     |  +-+     |          |
       | |     |  | |     |          |
 Q1  --+-+-----|--+-+-----|----------|
               |          |          |
         +-----|    +-----|          |
         |     |    |     |          |
 Q0  ----+-----|----+-----|----------|
     0        50        100        150

(우선 순위 상향이 있는 경우... 그림이 조금 괴랄하다. 별표 무더기는 입출력 작업이다.)
```

