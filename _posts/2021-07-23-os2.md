---
title: "OSTEP - 가상화: 프로세스 API"
lang: "ko"
layout: post
date: 2021-07-23 19:35:35 +0900
categories: [os,]
tags: [os,]
---

(OSTEP의 가상화 파트 중, 프로세스 API에 대해 정리하는 글입니다.)

UNIX 시스템은 실제로 어떻게 프로세스를 생성하는가? UNIX는 프로세스를 생성하기 위하여 fork()와 exec() 시스템 콜을 사용한다. wait()는 프로세스가 자신이 생성한 프로세스가 종료되기를 기다리기 원할 때 사용된다. (프로세스가 현재 시스템에서 실행중인 프로그램을 뜻한다는 사실을 잊지 말자!)

fork()는 자식(child) 프로세스를 생성하는 시스템 콜이다. 리눅스 시스템을 부팅할 때 스케줄러가 실행하는 init과 kthreadd와 같은 특별한 프로세스를 제외하면, 리눅스에서 모든 프로세스는 부모-자식 관계를 가지고 있다. 자식 프로세스는 부모(parents) 프로세스와 별도로 메모리 공간이 할당되지만, 자식 프로세스는 부모 프로세스와 동일한 메모리 내용을 가진다. 또한 자식 프로세스는 자신만의 주소 공간, 레지스터 그리고 프로그램 카운터(PC) 값을 갖는다. 즉, 새로 생성도니 프로세스는 생성된 이후 독립적으로 작동한다고 볼 수 있다. 중요한 점은, fork() 시스템 콜은 부모 프로세스에게 자식 프로세스의 **프로세스 식별자(process identifier, PID)**를 반환하고, 자식 프로세스에게는 **0**을 반환한다.

그러나 단일 CPU 프로그램에서 단순히 fork()를 호출하는 프로그램을 실행한다면, 프로세스가 생성되는 시점에 2개의 프로세스(부모와 자식) 중 하나가 실행되기에, 출력 결과가 항상 동일하지 않을 수 있다. 이러한 **비결정성(nondeterminism)**으로 인해 **멀티 쓰레드 프로그램** 실행 시 다양한 문제가 발생하게 된다.

항상 자식 프로세스의 작업이 먼저 수행되기를 원하는 프로그램과 같이, 부모 프로세스가 자식 프로세스의 종료를 대기해야 하는 경우, wait()(또는, waitpid()) 시스템 콜을 사용할 수 있다. 부모와 자식은 아무런 의존성(dependency)을 가지고 있지 않기 때문에, wait()을 호출한 부모 프로세스는 자식 프로세스의 종료 시점까지 자신의 실행을 잠시 중지시킬 수 있다. 자식 프로세스가 종료되면 wait()는 리턴한다. 이후 부모 프로세스의 작업이 실행된다.

![os_wait-syscall.jpg](https://typiespectre.github.io/images/os_wait_syscall.jpg){: width="90%" height="90%"}

exec() 시스템 콜은 자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용한다(즉, 새로운 실행파일을 실행시킨다. 참고로 리눅스에는 execl(), execle(), execlp(), execv(), execvp(), execve(), 총 여섯 개의 exec 시스템 콜이 있다). 실행해야 하는 프로그램의 이름과 인자들(arguments)이 주어지면, 기존 프로세스의 메모리 영역은 새로 실행되는 프로세스의 메모리 영역으로 교체된다. 즉, 프로그램의 코드와 정적 데이터를 읽어 들여 현재 실행중인 프로세스의 코드 세크멘트와 정적 데이터 부분을 덮어 쓰고, 새로운 프로그램의 실행을 위해 힙과 스택 및 다른 주소 공간들도 다시 초기화된다. 그런 다음 운영체제는 프로세스의 argv와 같은 인자를 전달하여 프로그램을 실행시킨다. 실행에 성공하면 *리턴을 하지 않고* 실행할 파일의 시작 지점의 명령어를 로드한다. (exec() 시스템 콜은 새로운 프로세스를 생성하지 않는다. 현재 실행중인 프로그램을 실행해야 하는 다른 프로그램으로 대체하는 것이다.)

exec() 예제:
```c
char *argv[3];

argv[0] = “echo”;
argv[1] = “hello”;
argv[2] = 0;
exec(“/bin/echo”, argv);
printf(“exec error\n”); // 만약 이 출력이 나온다면, exec()이 제대로 작동하지 않은 것이다.
```
<br />

![os_exec_syscall.jpg](https://typiespectre.github.io/images/os_exec_syscall.jpg){: width="90%" height="90%"}

그런데, 단순히 새로운 프로세스를 생성하는 일임에도, 이렇게 복잡한 인터페이스를 사용하는 이유는 무엇일까? UNIX의 쉘을 구현하기 위해서는, fork()와 exec()을 분리해야 한다. 그래야만 쉘이 fork()를 호출하고 exec()을 호출하기 전에, 프로그램의 환경을 설정하고 다양의 기능을 준비할 수 있는 코드를 실행할 수 있기 때문이다. 다시 말하면, fork()와 exec()을 분리함으로써, 새로운 프로그램이 실행되기 전에 다양한 세팅을 수행할 수 있으며, IO 리다이렉션과 파이프(pipe)를 형성할 수 있다.

대부분의 경우 쉘은 파일 시스템에서 실행 파일의 위치를 찾고 명령어를 실행하기 위하여 fork()를 호출하여 새로운 자식 프로세스를 만든다. 그런 후 exec()의 변형 중 하나를 호출하여 프로그램을 실행시킨 후 wait()를 호출하여 명령어가 끝나기를 기다린다. 자식 프로세스가 종료되면 쉘은 wait()로부터 리턴하고 다시 프롬프트를 출력하고 다음 명령어를 기다린다. 다음과 같은 입력/출력 재지정(I/O redirection)의 경우를 보자.

`prompt> wc p3.c > newfile.txt`{:.zsh}

이 경우, wc 프로그램의 출력은 newfile.txt라는 출력 파일로 **재지정(redirect)**된다. 이러한 작업을 수행하기 위해선, 자식 프로세스가 생성되고 exec()이 호출되기 전에 **표준 출력(standard output)** 파일을 닫고 newfile.txt를 열어야 한다. 이러한 작업을 수행하기 위해선 UNIX 시스템이 STDOUT_FILENO와 같은 파일 디스크립터를 탐색해야 한다. 예약된 파일 디스크립터 0에서 2번을 닫은(close) 후 바로 열어(open) 표준 입력, 표준 출력, 표준 오류를 사용자가 사용할 수 있다. 만약 파일 디스크립터 1번을 닫고 바로 텍스트 파일을 열면, 표준 출력 대신 텍스트 파일이 지정이 되었기 떄문에, 프로그램의 출력은 모두 화면이 아니라 파일로 보내진다. 쉘 명령어에서는 위와 같이 꺽쇠(>)로 리다이렉션을 설정할 수 있다.

* 파일 디스크립터란?
파일 디스크립터는 프로세스가 읽거나 쓰는 객체를 가리키기 위한 정수이다. 프로세스는 파일 디스크립터를 통해 파일 또는 디렉터리를 열거나, 파이프를 만들거나, 디스크립터를 복제할 수 있다. 프로세스마다 파일 디스크립터를 관리하기 위한 테이블이 존재하고, 파일 디스크립터 0,1,2는 각각 표준 입력(stdin), 표준 출력(stdout), 표준 오류(stderr)로 예약이 되어 있다. 위의 STDOUT_FILENO는 POSIX C의 <unistd.h>에서 지정된 표준 출력이다.

파일 디스크립터 예제:
```c
close(STDOUT_FILENO);
open("./p4.output", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
// 이후, execvp()를 호출하여 wc 프로그램이 실행된다.
char *myargs[3];
myargs[0] = strdup("wc");
myargs[1] = strdup("p4.c");
myargs[2] = NULL;
execvp(myargs[0], myargs); 
```
<br />

![os_fd.jpg](https://typiespectre.github.io/images/os_fd.jpg){: width="90%" height="90%"}
(보다 자세한 파일 디스크립터에 대한 논의는 이후에 다시...)

파이프(pipe)에 대해서도 간단하게 설명한다면, 파이프는 프로세스간 공유할 수 있는 커널 버퍼이다. 읽기와 쓰기를 위한 파일 디스크립터의 쌍으로 구성되어 있고, 한 쪽 끝에서는 데이터를 읽고, 다른 끝에서는 데이터를 쓴다. 임시 파일을 리다이렉션 하는 방법에 비해 파이프가 가지는 이점이 있다고 한다. 첫 번째로, 임시 파일을 이용한 방법은 임시 파일을 삭제할 때 사용자가 주의를 해야 하지만, 파이프는 운영체제가 자동적으로 관리를 한다. 두 번째로, 파일 리다이렉션 방식은 임시 파일을 디스크에 저장하여 사용해야 하지만, 파이프는 메인 메모리만 사용한다. 세 번째로 임시 파일은 데이터를 디스크까지 쓰고 응답을 받은 후에 다시 쓸 수 있기 때문에 병렬 처리가 불가능하지만, 파이프는 병렬 처리가 가능하다. 네 번쨰로, 파이프의 내부 구성에 의해 리다이렉션보다 더 나은 효율을 보여준다. 쉘 명령어에서는 OR( | )로 파이프를 설정할 수 있다.

`prompt> echo hello world | wc`{:.zsh}

![os_pipe.jpg](https://typiespectre.github.io/images/os_pipe.jpg){: width="90%" height="90%"}

복잡한 이야기에서 다시 돌아와, UNIX 시스템에는 fork(), exec(), 그리고 wait() 외에 많은 프로세스 관련 인터페이스가 있다. 예를 들면, Kill() 시스템 콜은 프로세스에게 멈추거나 끝내기와 같은 **시그널(signal)**을 보내는 데 사용된다. 시그널이라는 운영체제의 매커니즘은 외부 사건을 프로세스에게 전달하는 토대이다. 이 기반 구조는 시그널을 보내거나 전달받는 방법을 모두 포함한다. 개별적인 프로세스 단위 또는 프로세스 그룹 단위로 시그널을 받거나 처리할 수 있다. 이와 같은 통신이 가능하기 위해서 프로세스는 signal() 시스템 콜을 사용하여 여러 시그널을 잡아야 한다. 그러면, 특정 시그널이 프로세스에게 전달되었을 때, 해당 시그널에 정의된 코드를 실행하기 위해 정상적인 실행을 정지시킬 수 있다.

일반적으로, 우리가 사용하는 시스템은 동시에 여러 사용자가 접속할 수 있다. 그런데 만약 모든 사용자가 마음대로 시그널을 프로세스에게 보낸다면 시스템의 사용성이나 보안이 취약해질 수 있다. 그렇기에 현대의 시스템은 **사용자(user)** 개념을 도입하여, 인증된 사용자에게만 시스템의 자원에 접근할 수 있는 권한을 부여하는 방식을 사용한다. 운영체제는 CPU, 메모리와 디스크 같은 자원을 각 사용자와 프로세스들에 할당하여 전체적인 시스템의 목적에 도달하도록 만드는 역할을 한다. 더 나아가, **슈퍼사용자(superuser, root)**는 모든 프로세스들을 제어할 수 있고, 사용자는 수행할 수 없는 많은 일들을 직접 수행할 수 있다. 그러나 강력한 제어권에 걸맞는 커다란 위험이 따르기에, 슈퍼사용자는 보안상의 이유로 조심스럽게 사용해야 한다.

지금까지 UNIX의 프로세스를 다루는 기본적인 API를 살펴보았다. 그러나 UNIX 프로세스 API가 완벽한 피조물은 아니라고 한다. 가령 fork()에는 문제가 있기에, spawn()과 같은 간단한 프로세스 생성 API를 사용해야 한다는 연구 결과가 있다. 하지만, 가벼운 발걸음을 위해서 참고용으로만 알아두고자 한다...

* 주요 프로세스 API 용어들
- 각 프로세스는 이름이 있다. 대부분의 시스템에서 이름은 **프로세스 ID(PID)**라는 번호이다.
- UNIX 시스템에서는 **fork()** 시스템 콜을 사용하여 새로운 프로세스를 생성한다.
- **wait()** 시스템 콜은 자식 프로세스의 실행이 종료할 때까지 부모가 기다리도록 한다.
- **exec()** 계열의 시스템 콜은 자식 프로세스가 부모와의 연관성을 완전히 끊어서, 완전히 새로운 프로그램을 실행할 수 있도록 한다.
- UNIX 쉘은 보통 fork(), wait() 그리고 exec()을 사용하여 사용자의 명령을 시작한다. fork()와 exec() 명령을 분리하였기 때문에 실행중인 프로그램을 조작하지 않고도 **입력/출력 재지정, 파이프**, 그리고 다른 기능들을 처리하는 것이 가능하다.
- 프로세스 제어는 **시그널**이라는 형태로 제공되며, 이를 활용하여 작업을 멈추고, 계속 실행하고, 종료시킬 수 있다.
- 누가 어떤 프로세스를 제어할 수 있느냐는 **사용자**라는 개념 속에 포함되어 있다. 여러 사용자가 시스템을 사용할 수 있도록 허용하는 것과 사용자가 자신의 프로세스만 제어할 수 있게 만드는 것을 운영체제가 책임진다. **슈펴사용자**는 모든 프로세스들을 제어할 수 있지만, 보안상의 문제가 크기 떄문에 조심스럽게 그 역할을 맡아야 한다.
