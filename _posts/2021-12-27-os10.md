---
title: "OSTEP - 가상화: 주소 변환의 원리"
lang: "ko"
layout: post
date: 2021-12-27 15:54:39 +0900
categories: [os]
tags: [os]
---

사실 이번 챕터를 읽으며, 주소 공간의 역할은 대강 이해가 되지만, 주소 공간이 어디에 저장되는지는 조금 헷갈리는 상태이다. 그리고 주소 공간과 가상 주소 공간이 같은 것인지도... 일단 위키백과를 보고 이해한 바로는, 주소 공간은 운영체제가 메모리에 올라가는 각 프로세스에 제공하는 것이며, 주소공간의 크기는 CPU의 주소 버스의 크기에 의해 결정된다고 한다. 메모리의 물리적 주소와 프로그램에서 제시되는 주소값이 서로 다르기에(또한 사용자는 메모리의 물리적 주소를 직접 알 수도 없다) 서로 매핑을 해야만 하며, 이를 CPU의 MMU가 돕는다고 한다. 만약 그렇다면, 주소 공간은 추상화된 개념으로 존재하는 것인가? 아무튼 이는 차차 공부하며 알아봐야겠다.

이전에 **CPU 가상화**를 다루는 방식을 다시 떠올려보면, 프로세스가 시스템 콜을 호출하거나 타이머 인터럽트를 발생시킬 경우 운영체제가 개입하여 하드웨어를 직접 제어하는데, 이를 **제한적 직접 실행(LDE)**기법이라고 말하였다. 메모리 가상화에서도 비슷한 전략이 추구된다고 한다. LDE는 가상화를 제공하는 동시에 효율성(efficiency)과 제어(control)을 모두를 추구하는 기법이며, 효율성을 높이기 위해 하드웨어 지원을 활용한다. 메모리 가상화에는 이에 더해 *유연성(flexibility)* 측면을 다루고자 하며, 이를 바탕으로 하는 메모리 가상화에서 먼저 살펴볼 기법은, **하드웨어 기반 주소 변환(hardware-based address translation)**, 또는 **주소 변환(address translation)**이다. 주소 변환을 통해 **가상 주소(virtual address)**를 정보가 실제 존재하는 **물리 주소(physical address)**로 변환할 수 있다. (물론 이러한 변환이 하드웨어에 기반한다고는 하지만, 보다 정확한 변환을 위해서는 운영체제가 개입을 해야 할 것이다). 메모리 가상화의 목표는 *'프로그램에게 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상'*을 제공하는 것이다.

프로세스의 주소 공간은 다음과 같을 것이다:

```sh
0KB .------------.
1KB |program code|
2KB +------------+
3KB |    heap    |
4KB +------------+
    |	 ...	 |
...
    |            |
14KB+------------+
15KB| 3000, stack|
16KB.------------.

<그림 1> 프로세스와 그 주소 공간
```
<br />

그리고 프로세스가 아래와 같은 코드를 실행한다고 가정한다(메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 코드):

```c
void func() {
	int x = 3000;
	x = x + 3;	// 우리가 관심 있는 코드
```
<br />

컴파일러는 이 코드를 아래와 같은 어셈블리 코드로 변환할 것이다(x86 어셈블리로 변환한 결과. Mac에서는 `otool`을 사용하여 디스어셈블 할 수 있다).

```assembly
128: movl 0x0(\%ebx), \%eax ; 0+ebx를 eax에 저장
132: addl \$0x03, \%eax		; eax레지스터에 3을 더한다
135: movl \%eax, 0x0(\%ebx)	; eax를 메모리에 다시 저장
```
<br />

어셈블리 코드는 위 <그림 1>에서 프로그램 코드 영역에 순차적을 배치된다. 즉 세 개의 명령어의 코드는 상단 코드 섹션에서 각각 주소 128, 132, 135를 가지고, 변수 x의 값은 주소 15KB에 위치한다(아래 쪽 스택 영역. x의 초기 값 3000이 들어있다). 이 명령어가 실행되면 프로세스의 관점에서 다음과 같은 메모리 접근이 일어날 것이다:
- 주소 128의 명령어를 반입
- 이 명령어 실행(주소 15KB에서 탑재)
- 주소 132의 명령어를 반입
- 이 명령어 실행(메모리 참조 없음)
- 주소 135의 명령어를 반입
- 이 명령어 실행(주소 15KB에 저장)
<br /><br />

위의 <그림 1>을 보면, 프로그램의 관점에서 본 **주소 공간**은 주소 0부터 시작해서 최대 16KB까지이다. 그러나 메모리 가상화를 하기 위해선 운영체제는 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시켜야 한다. (왜냐하면 <그림 2>처럼, 물리 메모리의 첫 번째 슬롯은 운영체제 자신이 사용하고 있기 때문이다.) 즉 프로세스 주소 공간이 실제로는 다른 물리 주소에 배치되어 있음에도, 프로세스에게 주소 0번지부터 시작하는 가상 주소 공간이 주어진듯한 환상을 어떻게 제공할 수 있을까?

```sh
0KB  .------------.
     |     os     |
16KB +------------+
     | free space |
32KB +------------+
     |  프로세스    |
48KB +------------+
     | free space |
64KB .------------.

<그림 2> 하나의 재배치된 프로세스를 가진 물리 메모리
```
<br />

# 동적(하드웨어 기반) 재배치
첫 번째로 실현된 하드웨어 기반 주소 변환은 1950년대 첫 번째 시분할 컴퓨터에서 **베이스와 바운드(base and bound)**, 다른 이름으로는 **동적 재배치(dynamic relocation)**이라는 이름으로 등장하였다. 해당 기법을 구현하기 위해선, 각 CPU마다 2개의 하드웨어 레지스터가 필요한데, 하나는 **베이스(base)** 레지스터라 불리고, 다른 하나는 **바운드(bound)** 레지스터 혹은 **한계(limit)** 레지스터라고 불린다. 프로그램이 시작되면, 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정한 후, 베이스 레지스터를 그 주소로 지정하여, 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일된다. 즉 프로세스에 의해 생성되는 모든 주소가 다음과 같이 프로세서에 의해 변환된다:

```sh
physical address = virtual address + base
```
<br />

하드웨어는 베이스 레지스터의 내용을 가상 주소에 더하여 물리 주소를 생성한다. 만약 <그림 2>의 경우, 운영체제가 물리 주소 32KB에 저장하기로 결정하였다면, 베이스 레지스터의 값은 32KB가 된다. 그리고 프로그램이 실행되면...

```assembly
128: movl 0x0(\%ebx), \%eax
```
<br />

프로그램 카운터(PC)는 128로 설정되고, 하드웨어는 이 명령어를 반입할 때, PC값을 베이스 레지스터의 값 32KB(32768)에 더해, 32896의 물리주소를 얻는다. 그리고 하드웨어는 변환듼 물리 주소에서 명령어를 가져오고, 프로세스는 명령어의 실행을 시작한다. 중간에 가상 주소 15KB를 탑재하라는 명령어가 실행되면, 프로세서는 가상 주소에 베이스 레지스터(32KB)를 더하고 물리 주소 47KB에 해당 내용을 탑재한다. 이러한 가상 주소에서 물리 주소로의 변환을 **주소 변환**이라 부른다. *하드웨어는 프로세스가 참조하는 가상 주소를 받아들여 데이터가 실제로 존재하는 물리 주소로 변환한다.* 이러한 변환은 프로세스 실행 과정에서 나타나고, 실행 중에도 주소 공간을 이동할 수 있기에, **동적 재배치**라 부르기도 한다.

바운드(한계) 레지스터는 이러한 변환의 과정을 보호하는 역할을 한다. 만약 프로세스가 바운드 레지스터가 설정한 값보다 큰 가상 주소 또는 음수의 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스를 종료한다. 즉 바운드 레지스터의 역할은 프로세스가 생성한 모든 주소가 범위 내에 있는지 확인하는 것이다. 일반적으로 바운드 레지스터의 값은 프로세스의 주소 공간의 크기를 기준으로 한다. 따라서 <그림 1>과 같은 가상 주소를 갖는 프로세스의 경우, 바운드 레지스터는 16KB로 설정된다. (주소 공간의 마지막 물리 주소를 저장하는 방식도 존재한다.)

베이스와 바운드 레지스터를 이용한 주소 변환의 예제는 아래와 같다. 주소 공간의 크기가 4KB인 프로세스가 물리 주소 16KB에 탑재되어 있다면...

```sh
가상 주소    물리 주소
0       ->     16KB
1KB     ->     17KB
3000    ->     19384
4400    ->     폴트(바운드 벗어남)
```
<br />

베이스와 바운드 레지스터는 CPU에 존재하는 하드웨어 구조이다. 주소 변환에 도움을 주는 이러한 프로세서의 일부를 **메모리 관리 장치(memory management unit, MMU)**라고 부른다. 동적 재배치를 구현하기 위해 필요한 하드웨어의 지원은 다음과 같을 것이다:

- 운영체제의 특권모드(커널모드): 사용자 모드 프로세스가 특권 연산을 실행하는 것을 방지하기 위해 필요
- 베이스/바운드 레지스터: 주소 변환과 범위 검사를 지원하기 위하여 CPU당 한 쌍의 레지스터(MMU)가 필요
- 가상 주소를 변환하고 범위 안에 있는지 검사하는 능력: 즉 바운드 레지스터가 주소 변환과 범위 검사를 위한 하드웨어의 회로가 필요
- 베이스/바운드를 갱신하기 위한 특권 명령어: 프로그램 시작 전에 운영체제가 베이스와 바운드 레지스터 값을 지정할 수 있어야 함
- 예외 핸들러 등록을 위한 특권 명령어: 운영체제가 예외 처리 코드를 하드웨어에게 알려줄 수 있어야 함
- 예외 발생 기능: 프로세스가 특권 명령어 실행을 시도하거나 범위를 벗어난 메모리의 접근을 시도할 때 예외를 발생시킬 수 있어야 함 - 예외 핸들러(exception handler)
<br /><br />

동일하게 운영체제에도 다음과 같은 지원이 필요하게 된다:

- 메모리 관리: 새 프로세스의 메모리 할당에 필요, 종료 프로세스로부터 메모리 회수, **빈 공간 리스트(free list)**(사용중이지 않은 물리 메모리 영역의 리스트)를 통한 일반적인 메모리 관리
- 베이스/바운드 관리: 문맥 교환 시 올바르게 베이스/바운드 설정 - **프로세스 구조체(process structure)** 또는 **프로세스 제어 블럭(process control block, PCB)**
- 예외 처리: 예외가 발생할 때 실행할 코드, 범법 프로세스를 종료하는 것이 가능성이 높은 처리 방식
<br /><br />

**제한적 직접 실행** 프로토콜을 따른 동적 재배치는 운영체제의 개입이 적다. 메모리 변환이 운영체제의 개입 없이 하드웨어에 의해 처리되며, 대부분의 경우, 운영체제는 다만 하드웨어를 적절하게 설정하고, 프로세스가 CPU에서 직접 실행할 수 있게 하며, 프로세스가 잘못된 행동을 했을 때에만 개입한다.

주소 변환은 운영체제로 하여금 프로세스의 모든 메모리 접근을 제어할 수 있도록 한다. 이에 대한 하드웨어의 지원은 프로세스의 가상 주소를 물리 주소로 변환하는 과정을 빠르고 투명하게 수행할 수 있도록 돕는다. 베이스와 바운드(혹은 동적 재배치) 가상화 형태는 간단하기에 매우 효율적이고, 보호 기능도 제공할 수 있다. 하지만 할당된 영역에서 사용되지 않은 내부 공간을 낭비하게 되어, 다른 의미로는 비효율적이라고도 할 수 있다(즉 단편화가 발생되어 낭비된다). 이러한 유형의 낭비를 **내부 단편화(internal fragmentation)**이라 한다. 이를 방지하기 위해선 더 정교한 기법이 필요하다. 베이스와 바운드를 일반화는 기법, 즉 **세그멘테이션(segmentation)**을 통해 그러한 문제에 대응할 수 있다.

