---
title: "OSTEP - 가상화: 비례 배분 스케줄링"
lang: "ko"
layout: post
date: 2021-09-05 21:58:56 +0900 
categories: [os,]
tags: [os,]
---

역시 좀 더 간결하게 작성해야 하지 않을까 고민이다. 최대한 짧게 정리를 해보고자 한다.

**비례 배분(Proportional Share, 혹은 공정 배분 fair share)** 스케줄러는 **추첨 스케줄링(lottery scheduling)**을 이용하여 각 작업의 CPU 사용을 일정 비율 보장하는 것을 목적으로 한다. 

**추첨권(티켓)**은 추첨 스케줄링의 근간을 이룬다. 추첨권은 특정 자원에 대한 프로세스에게 할당될 몫(지분)을 나타낸다. 각 프로세스는 일정량의 추첨권을 가진다. 스케줄러는 추첨권의 총 개수를 파악한 뒤, 총 개수 내에서 무작위로 하나의 숫자를 뽑아, 어떤 프로세스가 뽑힌 추첨권의 값을 지니고 있는지 확인한 다음, 해당하는 프로세스를 실행한다. 예를 들어, 작업 A는 75장의 추첨권이 있고, 작업 B에는 25장의 추첨권이 있다고 하자. 곧, A는 0에서 74까지의 추첨권을, B는 75에서 99까지의 추첨권을 가지고 있다. 스케줄러는 0~99 사이의 값 중 한 값을 선정하여, 다음에 실행 할 프로세스를 결정한다.

이러한 무작위적인 방식이 각 작업의 CPU 사용을 일정 비율 보장할 수 있을까? 위의 예에선, 작업 A에겐 75%의 CPU 사용을, 작업 B에겐 25%의 CPU 사용을 목표로 한다. 시뮬레이션 결과, 단기간으로 보면, 무작위 선택은 일정 비율을 정확하게 보장하지는 않는다. 하지만 두 작업이 장기간 실행될수록, 원하는 비율을 달성할 가능성이 높아진다.

무작위적인 방식은 전통적인 결정 방식에 비해 세 가지 장점이 있다. 1) 무작위 방식은 전통적인 방식이 잘 해결하지 못하는 특이 상황에 잘 대응할 수 있다. 가령, 특정한 패턴에 의해 과도한 오버헤드로 최악의 성능이 발생하는 경우는 무작위 방식에선 발생하지 않는다. 2) 무작위 방식은 매우 가볍다. 왜냐하면 관리해야 할 상태 정보가 거의 없기 때문이다. 3) 무작위 방식은 매우 빠르다. 하지만, 이보다 속도를 더 빠르게 증가시키기 위해 덜 무작위(pseudo-random)하게 만들 수도 있다.

추첨권을 다루는 다양한 방법이 있다.
1. **추첨권 화폐(ticket currency)**: 이는 사용자가 추첨권을 자신의 기준대로 자유롭게 할당할 수 있도록 허용한다. 이러한 방식으로 선정된 모든 추첨권은 시스템에 의해 자동적으로 가치가 변환된다. 예를 들어, 사용자 A, B가 각 100장의 추첨권을 받았다고 가정하자. A는 자신의 작업에 1000장의 추첨권을, B는 10장의 추첨권을 가상적으로 부여하였다. 각 작업의 추첨권은 시스템의 전체 추첨권을 기준으로 하여 추첨권이 선정된다. 이 경우, 전체 추첨권은 200장이므로, A의 작업과 B의 작업 모두 동등하게 100장의 추첨권을 갖게 된다.
2. **추첨권 양도(ticket transfer)**: 이는 클라이언트/서버와 같은 환경에서 유리한 방식인데, 프로세스가 일시적으로 추첨권을 다른 프로세스에게 넘겨주는 방식이다. 클라이언트는 자신이 요청한 작업이 빨리 끝나도록 서버에 자신의 추첨권을 전달하여, 서버의 성능을 극대화시킬 수 있다. 요청을 완수하면 서버는 클라이언트의 몫을 다시 되돌려 준다.
3. **추첨권 팽창(ticket inflation)**: 이 기법은 프로세스가 서로를 신뢰하는 바탕 위에서 진행되어야 한다. 어떤 프로세스가 다른 프로세스보다 더 많은 CPU 시간을 필요로 할 경우, 다른 프로세스들과 통신하지 않고, 혼자 추첨권의 가치를 상향 조정한다.

추첨 스케줄링의 가장 큰 장점은 구현이 단순하다는 점이다. 필요한 것은 난수 발생기와 프로세스들의 집합을 표현하는 자료 구조, 추첨권의 전체 개수 뿐이다. 의사 코드는 아래와 같다:

```
1 	// counter: 당첨자를 발견했는지 추척하는데 사용됨
2 	int counter = 0;
3
4 	// winner: 0부터 총 추첨권 수 사이의 임의의 값을 얻기 위해 
5 	// 난수 발생기를 호출함 
6 	int winner = getrandom(0, totaltickets);
7
8 	// current: 작업 목록을 탐색하는 데 사용 
9 	node_t *current = head;
10
11 	// ticket의 값이 winner보다 더 클 때 까지 반복 
12 	while (current) {
13 		counter = counter + current->tickets;
14 		if (counter > winner)
15 			break; // 당첨자 발견 
16 		current = current->next;
17 	}
18 	// ’current’는 당첨자를 가리킴: 당첨자가 실행될 수 있도록 준비
```

위 의사 코드는 작업 목록을 순회하면서(작업 목록은 리스트로 되어있다고 가정한다) `counter`의 값이 `winner`의 값을 초과할 떄까지 각 추첨권 개수를 `counter`에 더한다. 값이 초과하게 되면 리스트의 현재 원소가 당첨자가 된다. 일반적으로 리스트를 내림차순으로 정렬하면 이 과정이 가장 효율적으로 된다. 이 경우, 리스트의 정렬은 검색 횟수가 최소화되는 것을 보장하기 때문이다.

하지만 추첨 스케줄링의 무작위성으로 인해 한 작업이 다른 작업보다 먼저 종료될 수 있다. 이는 스케줄러의 불공정성을 높인다. 시뮬레이션 결과, 작업 길이가 길지 않은 경우, 평균 불공정 정도는 심각하다. 작업이 충분한 기간 동안 실행되어야 추첨 스케줄러는 공정에 가깝게 도달한다. 또 다른 단점은, 시스템 동작이 추첨권 할당 방식에 따라 크게 달라짐에도 불구하고, 추첨권을 어떻게 배분해야 할지 쉽게 알 수 없다. 유일한 해결책은 사용자가 작업의 정보를 모두 알아서, 그에 맞게 추첨권을 배분하는 방식이지만, 이는 해결책이 아니다. 추첨권 할당 문제는 미해결 문제로 남아있다고 한다.

무작위성을 이용한 스케줄러는 단순하지만, 불공정해질 수 있다. 이를 보안하기 위해 공정 배분 스케줄러인 **보폭 스케줄링(stride scheduling)**이 고안되었다.

보폭 스케줄링에서, 각 작업은 **보폭(stride)**을 가지고 있다. 보폭은 자신이 가지고 있는 추첨권 수에 반비례하는 값이다. 예를 들어, 작업 A, B, C가 각각 100, 50, 200개의 추첨권을 가지고 있다고 가정해보자. 여기에 임의의 큰 값을 각자의 추첨권 개수로 나누면 보폭을 계산할 수 있다. 가령, 임의의 큰 값을 10000으로 설정한다면, 각 작업의 보폭은 100, 200, 40이 된다. 프로세스는 실행될 때마다 **pass**라는 값을 보폭만큼 증가시켜 얼마나 CPU를 사용하였는지 추적한 뒤, 가장 작은 pass 값을 가진 프로세스를 선택한다. 의사 코드는 아래와 같다:

```
current = remove_min(queue); 		// pass 값이 최소인 클라이언트로 선택
schedule(current); 			// 자원을 타임 퀀텀만큼 선택된 프로세스에게 할당 
current->pass += current->stride; 	// 다음 pass 값을 보폭 값을 이용하여 갱신 
insert(queue, current); 		// curr을 다시 큐에 저장한다
```

위 예를 적용한 스케줄러의 동작은 아래와 같다: 

```
                                         |                            
   Pass(A)        Pass(B)        Pass(C) |   실행은?                     
  (보폭=100)      (보폭=200)      (보폭=40) |                            
 ----------------------------------------|-----------                 
                                         |                            
      0              0              0    |     A                      
     100             0              0    |     B                      
     100            200             0    |     C                      
     100            200             40   |     C                      
     100            200             80   |     C                      
     100            200            120   |     A                      
     200            200            120   |     C                      
     200            200            160   |     C                      
     200            200            200   |    ...                     
                                         |              
```

결과적으로 C는 5번, A는 2번, B는 한 번 실행되었다. 이는 각자 가진 추첨권의 개수 250, 100, 50과 정확히 비례한다. 보폭 스케줄링은 각 스케줄링 주기마다 정확한 비율로 CPU를 배분한다.

그렇다면 추첨 스케줄링을 사용할 이유가 있을까? 추첨 스케줄링은 상태 정보가 필요 없기에, 새 프로세스를 쉽게 추가할 수 있다. 보폭 스케줄링의 경우, 새 프로세스가 들어온다면, 새 프로세스의 pass값을 어떻게 설정해야 할까? 추첨 스케줄링에는 이런 고민이 필요하지 않다.

Linux는 **Completely Fair Scheduler(CFS, 완전 공정 스케줄러)**라는 공정 배분 스케줄러를 사용한다. 이 스케줄러의 장점은 효율성과 확장성이다. CFS는 현존하는 공정성 배분 스케줄러 중 가장 널리 쓰인다고 한다.

CFS는 모든 프로세스들에게 CPU를 공평하게 배분하기 위하여, **virtual runtime(vruntime)** 테크닉을 사용한다. 프로세스가 실행되면, 스케줄러는 해당 프로세서의 `vruntime` 값을 누적시킨다(기본적으로 `vruntime`은 실제 시관가 같은 속도로 증가한다)). 스케줄링시 CFS는 _가장 낮은_ `vruntime`을 가진 프로세스를 다음에 실행할 프로세스로 선택한다.

CFS는 원활한 문맥 교환을 위해 다양한 통제 변수를 사용한다.
1. `sched_latency`: 이 값은 하나의 프로세서가 CPU를 사용한 후, 다음 번에 CPU를 사용할 수 있을 때까지의 최대 시간 간격을 나타낸다. 보통 `sched_latency` 값은 48(ms)로, CFS는 이 값을 현재 실행중인 프로세스의 개수로 나눠 프로세스의 타임 슬라이스를 결정한다. 너무 많은 프로세스가 들어와 너무 많은 문맥 교환이 발생하지 않도록, **최소 타임 슬라이스(`min_granularity`)**는 보통 6(ms)로 설정된다. CFS는 주기적으로 발생하는 타이머 인터럽트에 근간하여 작동하는데, 짧은 간격으로 발생하는 타이머 인터럽트를 통해 CFS는 현재 작업의 타임 슬라이스 소진 여부를 판단한다. 궁극적으로 CFS는 CPU의 공평한 배분을 가능하게 한다.
2. `niceness`: **가중치(Niceness)**라고 불리는 값은 프로세스의 우선 순위를 조정하는데 사용된다. CFS는 티켓이 아닌 (고전적 UNIX 메커니즘인) 프로세스의 **nice** 레벨을 사용하는데, nice가 양수 값이면 _낮은_ 우선순위를 의미하고 음수 값이면 _높은_ 우선순위를 의미한다. CFS는 각 프로세스의 nice값을 다음의 가중치(`weight`)에 대응시켜 놓았다(하지만, 값 자체는 중요하지 않다):

```
static const int prio_to_weight[40] = {
/* -20 */ 88761, 71755, 56483, 46273, 36291,
/* -15 */ 29154, 23254, 18705, 14949, 11916,
/* -10 */  9548,  7620,  6100,  4904,  3906,
/*  -5 */  3121,  2501,  1991,  1586,  1277,
/*   0 */  1024,   820,   655,   526,   423,
/*   5 */   355,   272,   215,   172,   137,
/*  10 */   110,    87,    70,    56,    45,
/*  15 */    36,    29,    23,    18,    15, 
};
```

이러한 가중치를 사용하여 프로세스의 우선순위를 고려하여 실질적인 타임 슬라이스를 계산할 수 있다(자세한 수식은 여기선 생략하도록 하겠다). 참고로 두 작업의 가중치는 가중치 값 자체에 의해서 바뀌는 것이 아닌, 두 작업 사이의 가중치의 거리에 의해 바뀐다. 가령 작업 A는 -5, 작업 B는 0의 nice값을 가지고 있었는데, 이를 각각 5와 10으로 올려도 두 작업 간의 스케줄링 방식은 변함이 없다. 가중치의 사용은 `vruntime`을 정교하게 사용하는데에도 도움을 준다. `vruntime`을 누적시키는 데 있어, nice값에 따라 누적시키는 양을 달리 하는 방식이다.

CFS는 프로세스 관리에 red-black 트리를 사용한다. 링크드 리스트는 프로세스의 개수와 리스트 검색 시간이 선형 비례한다. 단순 이진 트리는 최악의 경우, 리스트와 비슷한 삽입 성능을 갖는다. 이와 달리, 균형 트리의 일종인 red-black 트리는 참색 연산을 선형복잡도가 아닌 로그 시간의 복잡도로 수행할 수 있다. 다만 CFS가 모든 프로세스를 red-black 트리 형태로 관리하는 것은 아니다. 실행중이거나 실행 가능한 프로세스의 경우에만 이러한 트리 구조에 보관한다.

CFS는 잠자는 프로세스 문제도 다룰 수 있다. A와 B 두 프로세스가 있는데, A는 계속 실행해온 반면, B는 장시간(10초) 잠자고 있었다고 가정하자. B가 깨어나면, B의 `vruntime`은 A보다 10초 뒤쳐져 있을 것이기에, 다음 10초동안 B가 CPU를 독점하게 되고, A는 기아 상태에 빠지게 된다. CFS는 이를 해결하기 위해 깨어난 작업의 `vruntime`을 트리에서 찾을 수 있는 가장 작은 값으로 설정한다. 이로써 별다른 오버헤드 없이 프로세스의 기아 현상을 방지할 수 있다.

다만 모든 경우에서 완벽하게 좋은 성능을 보이는 스케줄러는 존재하지 않는다. 공정 배분 스케줄러의 경우, 입출력 스케줄러와 서로 맞물리게 되면, 자주 입출력을 수행하는 작업들에 공정하게 CPU가 할당되지 않을 수 있다. 작업에 티켓과 우선순위의 적절한 할당은 여전히 미해결 상태로 남아있다고 한다. 이전에 언급한 MLFQ와 같은 범용 스케줄러가 이러한 문제를 더 직관적으로 해결할 수 있고, 더 널리 쓰인다고도 한다. 다행인 점이라면, 배분 문제가 그렇게 중요하지 않은 경우가 많아서, 비례 배분을 사용해도 큰 문제가 없는 경우가 다수라고 한다.