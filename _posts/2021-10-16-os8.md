---
title: "OSTEP - 가상화: 주소공간의 개념"
lang: "ko"
layout: post
date: 2021-10-16 16:12:47 +0900
categories: [os]
tags: [os]
---

지금까지 CPU 가상화에 대한 내용을 다루었다. 머릿속에 떠오르는 대략적인 내용을 정리해보면, CPU의 가상화란, CPU가 하나의 프로세스만을 처리하지 않고, 다양한 프로세스를 운영체제의 정책에 따라 병렬적으로 처리함으로써, 사용자로 하여금 여러 개의 프로세스가 동시에 진행되는 듯한 환상을 제공하는 기법이라고 말할 수 있을 것 같다. 여러 개의 프로세스를 효율적으로 처리하는 다양한 스케줄러 기법들이 존재하고(SFJ, MLFQ, RR...), 여러 개의 프로세스 사이의 전환은 하드웨어의 타이머 인터럽트나 운영체제 내부의 트랩 정책으로 인해 가능해진다고 생각이 든다. 프로세스의 전환 뿐만 아니라, 프로세스 사이의 보안을 유지하는 것 또한 중요하며, 프로세스 자체에 대한 보안을 유지하기 위해 사용자 모드와 루트 모드를 구분하는 일 또한 운영체제의 핵심적인 과업일 것이다.

이제 메모리 가상화에 대한 내용으로 넘어갈 차례이다. 메모리 가상화에서 가장 기본적으로 짚고 넘어가야 할 점은, **사용자 프로그램이 생성하는 모든 주소는 가상주소**라는 점이다. 그렇게 함으로써 프로세스는 자신만의 커다란 전용 메모리를 가진다는 환상을 가질 수 있다.

**멀티프로그래밍(multi-programming)**의 (여러 개의) 프로세스 전환을 통한 **효율성**의 개선이나, 일괄처리방식(batch computing)의 한계를 극복하고자 등장한 **시분할(time-sharing)** 기법 그리고 **대화식 이용(interactivity)** 등은 운영체제의 메모리 관리에도 복잡한 문제를 제기하였다. 운영체제는 빠른 속도로 프로세스를 전환하기 위해 프로세스를 그대로 메모리에 유지하면서, 시분할 시스템을 효율적으로 구현해야하는 임무를 지니게 된다. 또한 여러 프로그램에 메모리에 동시에 존재함으로써, **보호(protection)** 문제 또한 중요한 이슈가 되었다.

```
                                  
       0KB +---------------------+
           |        운영체제        |
           |    (코드, 데이터 등)    |
       64KB-----------------------
           |                      |
           |       (빈 공간)        |
      128KB-----------------------
           |        프로세스C       |
           |    (코드, 데이터 등)    |
      192KB-----------------------
           |        프로세스B       |
           |    (코드, 데이터 등)    |
      256KB-----------------------
           |                     |
           |       (빈 공간)       |
      320KB-----------------------
           |                     |
           |       (빈 공간)       |
      384KB-----------------------
           |        프로세스A       |
           |    (코드, 데이터 등)    |
      448KB-----------------------
           |                     |
           |       (빈 공간)       |
      512KB+---------------------+

그림 1: 세 개의 프로세스 - 공유 메모리
(역시 다른 툴을 구해야겠어...)
```
<br />

그러한 문제들을 해결하기 위해 나온 메모리 개념이 바로 **주소 공간(address space)**이다. 주소 공간은 실행 프로그램의 모든 메모리 상태를 갖고 있다. 즉, 프로그램의 **코드(명령어)**는 반드시 메모리에 존재해야 하고, 따라서 주소 공간에 존재한다. 주소 공간의 구성 요소는 코드 외에도, 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 **스택(stack)**과 동적으로 할당되는 메모리를 위해 사용되는 **힙(heap)** 등이 존재한다.

코드는 정적이기 떄문에 주소 공간의 맨 위에 배치한다. 정적이라는 말은, 프로그램이 실행되면서 추가 메모리를 필요로 하지 않음을 의미한다. 힙과 스택은 메모리 영역의 확장을 필요로 하기 때문에 (관례적으로) 각각 상단과 하단에 배치한다. 힙은 코드 바로 뒤 1KB로부터 시작하고 아래 방향으로 확장한다(예를 들면, 사용자가 `malloc()` 함수를 통해 더 많은 메모리를 요청할 때). 스택은 16KB에서 시작하고 위쪽 방향으로 확장한다(예를 들어, 사용자가 프로시저를 호출할 때).

```
                           
   0KB +------------------+    코드 세그먼트:
       |    프로그램 코드     |    명령어가 사는 곳
   1KB -------------------+    힙 세그먼트:
       |        힙         |    malloc된 데이터,
   2KB -------------------+    동적 자료 구조 포함.
       |                  |    (아래쪽으로 커진다)
       |                  |
       |                  |
       |     (빈 공간)      |
       |                  |
       |                  |
       |                  |
       |                  |    (위쪽으로 커진다)
  15KB -------------------+    스택 세그먼트:
       |       스택        |    지역 변수, 루틴의 인자,
  16KB +------------------+    반환 값 등 포함

그림 2: 주소 공간의 예
```
<br />

결론적으로, 문제는 다음과 같다: *운영체제는 물리 메모리를 공유하는 다수의 프로세스에게 어떻게 프로세스 전용의 커다란 주소 공간이라는 개념을 제공할 수 있는가?* 운영체제는 **메모리를 가상화(virtualizing memory)**함으로써 문제를 해결한다. 운영체제가 어떻게 메모리 가상화를 이루어내는지는 앞으로의 논의를 통해 차차 파악하도록 하자.

운영체제가 메모리 가상화를 하기 위해선 몇 가지 목표가 필요하다. 가상 메모리 시스템(VM)의 주요 목표 중 하나는 **투명성(transparency)**으로, 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 한다. 즉, 프로그램은 자신이 전용 물리 메모리를 소유한 것처럼 행동해야 한다. 조금 헷갈릴 수 있는 점으로는, '투명하다'라는 용어가 보통 모든 것이 숨김없이 밝혀진다는 의미를 가지고 있는 반면, 여기서의 '투명함'은, 일반적인 사용에서 그 시스템을 인지하기 어려움을 의미한다. VM의 또 다른 목표로는 **효율성(efficiency)**과 **보호(protection)**가 있다. 특히 보호에 있어서, 운영체제는 *마이크로커널*과 같은 **격리(isolate)**를 통해, 프로세스를 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호함으로써 신뢰성을 형성해야 한다.

앞으로의 내용은, 메모리 가상화의 다양한 기법들과 운영체제의 정책들을 집중적으로 탐구한다. 마지막으로 한 번 더 기억해야 할 점은, 사용자 프로그램(user level program)이 볼 수 있는 주소는 모두 가상 주소라는 것이다. 물리 메모리 주소를 알 수 있는 것은 오직 운영체제뿐이다.