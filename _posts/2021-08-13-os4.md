---
title: "OSTEP - 가상화: 스케줄링 개요"
lang: "ko"
layout: post
date: 2021-08-13 16:54:56 +0900
categories: [os,]
tags: [os,]
---

(OSTEP의 가상화 파트 중, 스케줄링 : 개요에 대해 정리하는 글입니다. 이전에는 책 내용을 맥락에 따라 전반적으로 정리를 했는데, 왠지 너무 길어지게 되는 것 같아, 이번부턴 핵심 내용을 중심으로 짧게 정리해보려고 합니다. 인터넷이나 ppt에서 찾아본 개념도 있기에, 글의 모든 내용이 책에 그대로 서술되어 있는 것은 아닙니다.)

- - -

문맥교환과 같은 저수준 기법을 넘어서, 이번 파트는 운영체제 스케줄러의 고수준 정책에 관하여 이야기한다. 스케줄링의 기원은 컴퓨터가 탄생하기 이전, 생산 관리 분야(Operation Management)에서 시작되었다. 효율적인 생산을 위해 인간의 행동에 스케줄링이 필요하듯, 컴퓨터의 효율적인 프로세스 처리를 위해 운영체제는 스케줄링 정책을 제공한다. 프로세스가 동작하는 일련의 행위를 **워크로드(workload)**라 한다.

스케줄링 정책을 설명하기 앞서, 스케줄링 정책을 보다 쉽게 설명하기 위해 교재는 실행중인 프로세스 혹은 작업(job)에 대해 다음과 같은 이상적인 가정을 한다.

1. 모든 작업은 같은 시간 동안 실행된다.
1. 모든 작업은 동시에 도착한다.
1. 작업은 일단 시작하면 최종적으로 종료될 때까지 실행된다.
1. 모든 작업은 CPU만 사용한다(즉, 입출력을 수행하지 않는다).
1. 각 작업의 실행 시간은 사전에 알려져 있다.
<br />

# 스케줄링의 평가 항목(scheduling metric)

## 반환 시간(turnaround time)    

반환 시간은 작업이 메모리에 들어가기까지 걸린 시간, 준비 큐에 머무르는 시간, 실행 시간, 입출력 시간 등 **작업을 완료하는데 소요되는 시간**이다. 반환 시간은 작업이 완료된 시각에서 작업이 도착한 시간을 뺀 시간으로 계산한다. 공식은 아래와 같다:

T<sub>turnaround</sub> = T<sub>completion</sub> - T<sub>arrival</sub>

(모든 작업은 동시에 도착한다는 교재의 조건을 적용한다면, T<sub>arrival</sub>=0이 될 것이다.)

반환 시간은 **성능** 측면에서의 평가 기준이다. 다른 평가 기준으로 **공정성(fairness)**이 있다. 성능과 공정성은 서로 상충되는 기준인데, 가령 성능을 극대화하기 위해 스케줄러가 몇몇 작업에 실행 기회를 주지 않는 경우, 공정성은 악화될 것이다 (하지만 교재의 말마따나, _인생의 대부분은 완벽하지 않다_). 새로운 평가 항목을 설명하기 전에, 몇 가지 스케줄링 알고리즘을 살펴보겠다.

## 선입선출(First In First Out, FIFO)

단순하고, 구현하기 쉬운 가장 기본적인 알고리즘으로 FIFO가 있다. FIFO는 말 그대로, 가장 먼저 온 프로세스부터 처리하는 알고리즘이다. 예를 들어, 교재의 조건을 적용하여, 작업 실행 시간 10의 작업 A,B,C가 순서대로 도착하였다면, 다음과 같은 방식으로 처리 될 것이다.

```
+-----+-----+-----+         
|     |     |     |         
|     |     |     |         
|  A  |  B  |  C  |         
|     |     |     |         
|     |     |     |         
+-----+-----+-----+-------
0          20          40   
```
<그림 1>

그림 1에서 A는 10, B는 20, C는 30에 종료했다. 세 작업의 평균 반환 시간은 (10+20+30)/3 = 20이 된다.

하지만 교재의 조건 1을 완화하여, 작업의 작업 실행 시간이 모두 같지 않다면 FIFO의 문제는 분명하게 드러나게 된다. 만약 A의 실행시간이 100이고, B와 C의 실행시간이 10이라면, 시스템의 평균 반환 시간은 (100+110+120)/2 = 110이 되어, 좋지 않은 성능을 보여준다. 이렇듯, CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상을 **convoy effect**라고 부른다.

## 최단 작업 우선(Shortest Job First, SJF)

convoy effect를 해결하기 위해선, 가장 짧은 실행 시간을 가진 작업을 먼저 실행시키는 SJF를 사용하면 된다. SJF는 평균 반환 시간(혹은 작업당 완료시간)이 강조되는 모든 시스템에 적용할 수 있다고 한다. 위의 convoy effect가 발생하는 상황에 SJF를 적용하면 다음과 같을 것이다.

```
+----+----+-------------------------------------------------+ 
|    |    |                                                 | 
|    |    |                                                 | 
| B  | C  |                       A                         | 
|    |    |                                                 | 
|    |    |                                                 | 
+----+----+-------------------------------------------------+ 
0         20                                               120
```
<그림 2>

B,C,A 순서대로 실행시킴으로써, 평균 반환 시간은 (10+20+120)/3 = 50이 된다. FIFO와 비교하여 볼 때 2배 이상 성능이 향상되었음을 알 수 있다.

모든 작업이 동시에 도착한다면 SJF가 최적의 스케줄링 알고리즘이 될 것이다. 하지만 이제 교재의 가정 2번을 완화하여, 모든 작업이 동시에 도착하는 것이 아니라면, 이전처럼 convoy 문제가 동일하게 발생할 수 있다. 예를 들어, B,C보다 A가 먼저 도착한다면, B와 C가 A보다 작업 실행 시간이 짧음에도, A를 먼저 수행할 수밖에 없을 것이다.

## 최소 잔여시간 우선(Shortest Time-to-Completion First, STCF)

이 문제를 해결하기 위해선 가정 3을 완화해야 한다. 즉, 작업은 실행 도중에 중단될 수 있다. 타이머 인터럽트와 문맥 교환을 가능하게 함으로써, 스케줄러는 A를 먼저 실행하다가, 이후 B와 C가 도착하였을 경우, 하던 일을 중단하고 다른 작업을 수행할 수 있게 된다. 앞서 다룬 SJF는 **비선점(non-preemptive)** 스케줄러이기 때문에, 실행중인 작업을 중지하고 다른 작업을 실행하지 못한다. STCF(또는, PSJF: 선점형 최단 작업 우선)는 SJF에 선점 기능을 추가한 스케줄러로서, 현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.

```
+----+----+----+--------------------------------------------+ 
|    |    |    |                                            | 
|    |    |    |                                            | 
| A  | B  | C  |                  A                         | 
|    |    |    |                                            | 
|    |    |    |                                            | 
+----+----+----+--------------------------------------------+ 
0         20        40                                     120
```
<그림 3>

A의 작업 실행 시간이 100이고, B와 C의 작업 실행 시간은 10인 반면, A는 t=0에 바로 실행되지만 B와 C는 t=10에 도착한다고 가정한다면, 평균 반환 시간은 ((120-0)+(20-10)+(30-10))/3 = 50이 된다. 만약 SJF를 사용하였다면 (100+(110-10)+(120-10))/3 = 103.33이 될 것이다.

## 새로운 평가 기준: 응답 시간(response time)

만약 평가 기준이 반환 시간 하나라면, STCF는 매우 훌륭한 정책이 될 것이다. 하지만 우리는 시분할 컴퓨터를 사용하여, 시스템과 활발한 상호작용을 하게 된다. 이와 관련된 성능 평가 기준으로 응답 시간이 등장하였다. 응답 시간은 작업이 도착하는 시점부터 처음 스케줄 될 때까지의 시간으로 정의돤다.

T<sub>response</sub> = T<sub>firstrun</sub> - T<sub>arrival</sub>

예를 들어, 위처럼 A가 시간 0에 도착하고, B와 C는 시간 10에 도착하는 스케줄의 경우, 각 작업의 응답 시간은 A는 0, B는 0, C는 10이 되어, 평균 3.33이 된다.

STCF정책의 응답시간이 짧지 않음은 당연하다. 왜냐하면 3개의 작업이 동시에 도착한 경우, 세 번쨰 작업은 딱 한 번 스케출 되기 위해 먼저 실행된 두 작업이 _완전히 끝날 때까지_ 기다려야 하기 때문이다. 반환 시간 기준으로는 훌륭하지만, 응답 시간과 상호작용 측면에서는 나쁜 방법이다(터미널에 간단한 명령어를 하나 입력했는데, 먼저 수행되어야 하는 다른 일 때문에 응답을 받기 위해 10초 이상 기다려야 한다고 생각해보자).

## 라운드 로빈(Round-Robin, RR)

응답 시간 문제를 해결하기 위하여 RR 스케줄링 알고리즘이 도입되었다. RR은 작업이 끝날 때까지 모두 기다리지 않고, 일정 시간 동안 실행한 후 실행 큐의 다른 작업으로 전환한다. 작업이 실행되는 일정 시간을 **타임 슬라이스(time slice)** 또는 **스케줄링 퀀텀(scheduling quantum)**이라 부른다. 타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수여야 한다.

3개의 작업 A,B,C가 시스템에 동시에 도착하고, 각각 5초간 실행된다고 가정해보자. SFJ와 비교하여 RR은 다음과 같이 작업을 처리할 것이다:

```
SFJ:

+----+----+----+                                            
|    |    |    |                                            
|    |    |    |                                            
| A  | B  | C  |                                            
|    |    |    |                                            
|    |    |    |                                            
+----+----+----+------                                      
0    5    10   15

RR:

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                             
| | | | | | | | | | | | | | | |                             
| | | | | | | | | | | | | | | |                             
|A|B|C|A|B|C|A|B|C|A|B|C|A|B|C|                             
| | | | | | | | | | | | | | | |                             
| | | | | | | | | | | | | | | |                             
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-------                      
0         5         10        15     
```
<그림 4>

SJF 스케줄러는 다른 작업을 실행하기 전에 각 작업을 종료할 때까지 실행한다. 반면, 1초의 타임 슬라이스를 가진다고 가정한다면 RR은 작업을 빠르게 순환하여, SJF의 평균 응답 시간은 (0+5+10)/3 = 5인 반면, RR의 평균 응답 시간은 (0+1+2)/3 = 1이 된다.

위에서 알 수 있듯, 타임 슬라이스의 길이는 RR에게 매우 중요하다. 타임 슬라이스가 짧을수록, 응답 시간 기준 RR의 성능은 더 좋아진다. 그러나 너무 짧게 지정한다면, 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 되기에, 적절한 길이를 조정하는 것이 중요하다.

하지만, 반환 시간 기준 RR의 성능은 매우 좋지 않다! A는 13, B는 14, C는 15에 종료하게 되어, 평균 14의 반환 시간을 가지게 될 것이기 때문이다. 반환 시간이 유일한 측정 기준이라면 RR은 최악의 정책이 될 것이다. 하지만 RR의 목표는 프로세스의 공정성과 최선의 응답 시간을 보장하는 것이다. 만약 반환 시간도 고려해야 한다면, 응답 시간을 어느 정도 포기해야 할 것이다. 반환 시간과 응답 시간은 일종의 트레이드 오프 관계이다.

## 입출력 연산의 고려

가정 4를 완화하여, 모든 프로그램이 입출력 작업을 수행한다고 하자. 현재 실행중인 프로세스가 입출력 작업을 요청할 경우, 해당 작업은 입출력이 완료될 때까지 CPU를 사용하지 않고, 입출력 완료를 기다리며 대기 상태가 된다. 스케줄러는 그 시간 동안 실행될 다른 작업을 스케줄 해야 한다. 즉, 한 작업의 대기 시간 동안, 다른 작업의 연산을 수행하는 것이다. 이러한 연산의 **중첩**은 시스템의 활용도를 극대화할 수 있다. 대화형 작업이 입출력을 실행하는 동안 다른 계산 위주의 작업들을 실행함으로써, CPU의 이용률은 더 높아지게 된다.

지금까지 가정 1번부터 4번까지 완화하여, 각 스케줄러의 장단점과 가장 적절한 해결책을 살펴보았다. 마지막 가정은 스케줄러가 각 작업의 실행 시간을 알고 있다는 것이다. 하지만 일반적인 운영체제에서, 작업의 길이를 미리 알 수 있는 길은 없다. 정확한 스케줄링을 위해선 프로세스의 미래 동작을 예측해야 할 것이다. 이를 최대한 극복하기 위해, 과거의 프로세스 동작 이력을 반영하는 방식으로 문제를 해결한다고 한다. 이 스케줄러를 **멀티 레벨 피트백 큐(multi-level feedback queue)**라고 한다고 하는데, 이는 다음 장에서 계속 살펴보게 될 것이다.