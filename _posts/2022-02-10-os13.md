---
title: "OSTEP - 가상화: 페이징 - 더 빠른 변환(TLB)"
lang: "ko"
layout: post
date: 2022-02-10 20:04:30 +0900
categories: [os]
tags: [os]
---

앞서 보았듯이, 운영체제가 페이징 기법을 적용하기 위해선 페이지 매핑 정보를 저장하기 위한 메모리 공간이 요구된다. 그리고 가상주소에서 물리주소로 변환을 하기 위해선 메모리에 존재하는 매핑 정보를 읽기 위한 메모리 접근이 발생하고, 이는 커다란 성능 저하를 가져올 수 있다. 운영체제는 실행 속도의 개선을 위해 하드웨어를 사용할 수 있다. 그리고 운영체제는 주소 변환을 빠르게 하기 위해 **변환-색인 버퍼(translation-lookaside buffer, TLB)**라고 불리우는, 칩의 **메모리 관리부(memory-management unit, MMU)**의 일부를 사용한다. TLB는 자주 참조되는 가상주소와 물리주소의 변환 정보를 저장하는 하드웨어 캐시이다. 가상 메모리를 참조하는 경우, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지 확인하고, 만약 있다면 (메모리 상에서 모든 변환 정보를 갖고 있는) 페이지 테이블에 접근하지 않고 변환을 빠르게 수행할 수 있다. 따라서 TLB는 페이징 성능을 향상시킨다.

## TLB 개요

TLB의 기본 알고리즘은 다음과 같다:
1) 가상주소에서 가상 페이지 번호(virtual page number, VPN)을 추출한 후, 해당 VPN의 TLB 존재 여부를 검사한다.
2) 만약 존재하면 TLB가 변환 값을 갖고 있다는 뜻이므로, **TLB 히트**이다.
2-1) TLB 히트일 경우, 해당 TLB 항목에서 페이지 프레임 번호(page frame number, PFN)를 추출한다. 먼저 해당 페이지에 대한 접근 권한 검사를 하고, 해당 페이지의 정보를 원래의 가상주소의 오프셋과 합쳐 원하는 물리주소를 구성하고, 메모리에 접근한다.
3) 만약 존재하지 않는다면, **TLB 미스**이다.
3-1) TLB 미스일 경우, 먼저 하드웨어가 변환 정보를 찾기 위해 페이지 테이블에 접근한다.
3-2) 프로세스가 생성한 가상 메모리 참조의 유효성을 확인한 후, 해당 페이지 정보를 TLB로 읽어들인다. 페이지 테이블 접근을 위한 메모리 참고로 인해 시간이 많이 소요된다.
3-3) TLB가 갱신되면 하드웨어는 명령어를 재실행한다.
3-4) 이번에는 TLB에 변환 정보가 존재함으로, 메모리 참조가 빠르게 처리된다.

TLB는 프로세싱 코어와 가까운 곳에 위치하고, 매우 빠른 하드웨어로 만들어져, TLB 히트가 발생하면 주소 변환 작업은 아주 빠르게 이루어진다. 하지만 TLB 미스가 발생하면 메모리 참조 과정이 추가되므로, 페이징 비용이 커진다. 메모리 접근 연산은 다른 CPU 연산에 비해 매우 시간이 오래 걸린다.

다음과 같은 예제를 생각해볼 수 있다: 가상 주소 100번지부터 10개의 4바이트 크기의 정수 배열이 존재한다고 가정하자. 각 가상 주소 공간은 8비트이며, 페이지 크기는 16바이트이다. 가상주소는 4비트 VPN(16개의 가상 페이지들을 표현)과 4비트 오프셋(각 페이지는 16바이트 크기를 가짐)으로 구성된다. 배열은 크기가 16바이트인 16개의 페이지로 구성된 가상 주소 공간에 다음과 같이 그려질 것이다.

```
                      offset
         0      04      08      12      16
         +------------------------------+
VPN = 01 |                              |
         +------------------------------+
VPN = 02 |             ...              |

         +------+-------+-------+-------+
VPN = 06 |      | a[0]  | a[1]  | a[2]  |
         +------+-------+-------+-------+
VPN = 07 | a[3] | a[4]  | a[5]  | a[6]  |
         +------+-------+-------+-------+
VPN = 08 | a[7] | a[8]  | a[9]  |       |
         +------+-------+-------+-------+
VPN = 09 |             ...              |

VPN = 15 |                              |
         +==============================+
```
<br />

TLB가 완전히 초기화되었다고 가정하면, 첫 번째 a[0] 배열 접근은 당연히 TLB 미스가 일어난다. 하드웨어는 가상주소에서 VPN을 추출하여 해당 VPN에 대한 물리 페이지 번호를 찾아 TLB를 갱신한다. 다음 배열 a[1]은 TLB 히트가 발생한다. 왜냐하면 a[1] 배열은 a[0] 배열과 같은 페이지에 존재하기 때문이다. _첫 번째 배열 항목을 읽을 때, 이미 해당 페이지를 접근하였기 때문에, 필요한 변환 정보가 이미 TLB에 탑재되어 있다._ 동일하게 a[3] 배열을 읽을 때는 미스가 발생하지만, a[4], a[5], a[6]을 읽을 때는 히트가 발생한다. 결과적으로 <미스 - 히트 - 히트 - 미스 - 히트 - 히트 - 히트 - 미스 - 히트 - 히트>로 TLB는 동작하게 된다.

위처럼, TLB는 **공간 지역성(spatial locality)**으로 성능이 개선될 수 있다. 배열의 항목들이 페이지 내에서 서로 인접해 있다면, 하나의 미스로 다수의 히트를 이루어낼 수 있다. 또한 페이지 크기는 TLB의 효용성에 중요한 역할을 한다. 만약 페이지 크기가 두 배가 되면(16이 아니라 32바이트), 위와 같은 연속적인 정수 배열 접근의 경우, 성능이 훨씬 개선될 것이다. 그리고 프로그램이 루프 종료 후에도 배열을 사용한다면 성능은 더욱 개선될 수 있다. 왜냐하면 모든 주소 변환 정보가 TLB에 탑재되어 있기 때문이다. 이는 **시간 지역성(temporal locality)**으로 TLB의 성능이 개선되는 것으로 볼 수 있다. 시간 지역성이란, 한번 참조된 메모리 영역이 짧은 시간 내에 재 참조되는 현상을 일컫는다.

따라서 TLB는 캐시 사용과 마찬가지로, 공간 지역성과 시간 지역성을 최대한 활용하는 것이 관건이다. 그렇다면 초대용량 TLB를 만들면 모든게 해결되지 않을까? 하지만 단순하게 답을 내린다면, 빠르게 하려면 크기가 작아야 한다고...

## TLB 미스는 누가 처리할까?

TLB 미스의 처리는 하드웨어와 소프트웨어로 나눠진다. 과거에는 **CISC(complex-instruction set computers)**라는 컴퓨터 구조로, 하드웨어가 TLB 미스를 처리하도록 설계했다. 인텔 x86 CPU가 하드웨어로 관리되는 TLB의 대표적인 예이다. 
