---
title: "OSTEP - 가상화: 세그멘테이션"
lang: "ko"
layout: post
date: 2022-01-09 20:37:54 +0900
categories: [os]
tags: [os]
---
이전의 베이스-바운드 방식의 단점은, 간단한 구현이 가능함에도 불구하고 스택과 힙 사이에 사용되지 않는 공간이 그대로 남아있게 된다는 점이다. 즉 유연성이 떨어지기에 메모리 낭비가 심하고, 주소 공간이 물리 메모리보다 큰 경우 실행이 어렵게 된다.이 문제를 해결하기 위해 **세그멘테이션(segmentation)**이라는 아이디어가 등장했다.

세그멘테이션을 적용할 경우 **세그멘트(segment)**의 개수만큼 MMU에 베이스와 바운드값이 존재하게 된다. 세그멘트는 특정 길이를 가지는 연속적인 주소 공간으로(교재의 주소 공간의 경우, 코드와 스택 및 힙의 세 종류의 세그멘트가 있다), 세그멘테이션을 사용하면 운영체제는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있게 되어, 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있다.

```
 0KB +------------+           0KB +------------+
 1KB |program code|               |     OS     |
 2KB +------------+          16KB +------------+
 3KB |            |               |  (unused)  |
 4KB +------------+               +------------+
 5KB |            |               | ...stack   |
 6KB |    heap    |          32KB +------------+
 7KB +------------+               |program code|
 8KB |            |               +------------+
 ...                              |    heap... |
14KB +------------+          48KB +------------+
15KB |   stack    |               |  (unused)  |
16KB +------------+          64KB +------------+

    <address space>             <physical memory>

그림 1. 주소 공간과 세그멘트가 배치된 물리 메모리
```
<br />
그림 1을 보면, 사용 중인 메모리에만 물리 공간이 할당되어, 사용되지 않은 영역이 많은 대형 주소 공간(**드문드문 사용되는 주소 공간(sparse address space)**)을 수용할 수 있다. 이 경우, 세 쌍의 베이스와 바운드 레지스터 집합을 담을 수 있는 MMU 하드웨어 구조가 필요하다. 각 바운드 레지스터는 세그멘트의 크기를 저장한다.

```
segment    base    size
-----------------------
 code      32KB     2KB
 heap      34KB     3KB
stack      28KB     2KB

그림 2. 세그멘트 레지스터의 값
```
<br />
### 프로그램 코드와 힙

코드와 힙의 주소 공간의 주소 변환의 과정은 다음과 같다:
1. 가상 주소 100번지(100B)를 참조하는 경우, 하드웨어는 (가상 주소 100번지에 속하는) 코드 세그먼트의 베이스 값에 해당 세그먼트의 _오프셋_(이 경우, 100)을 더해, 물리 주소는 100+32KB = 32868이 된다. 그리고 해당 가상 주소가 범위 내에 있는지 검사하고(100은 바운드값인 2KB보다 작다), 범위 내에 있을 경우, 물리 메모리 주소 32868을 읽는다.
2. 가상 주소 4200번지(4200B)를 참조하는 경우, 하드웨어는 가상 주소 4200에 속하는 힙 세그먼트를 읽게 되는데, 주의해야 할 점이 있다. 가상 주소 4200을 힙의 베이스(34KB)에 더하면 물리 주소 39016을 얻게 되지만, 이는 올바른 물리 주소가 아니다(**왜냐하면 힙이 가상 주소의 중간에 위치하기 때문이다**). 먼저 힙 안에서의 _오프셋_, 즉 주소가 참조하는 바이트가 해당 _세그먼트_의 시작으로부터 몇 번째 바이트인지를 얻는다. 힙은 가상 주소 4KB(4096)에서 시작하므로, 실제 _오프셋_은 4200 - 4096 = 104가 된다. 이 오프셋(104)을 베이스 레지스터의 베이스(34KB)에 더한 34920이 힙의 물리 주소가 된다. (만약 힙의 마지막인 7KB를 벗어나는 주소에 접근하고자 하게 되는 경우, 하드웨어는 주소의 범위를 벗어남을 감지하고 운영체제에 트랩을 발생시킨다. 이것이 유명한 **세그멘트 폴트(segment fault)**이다!)

<br />
하드웨어는 가상 주소가 어느 세그멘트를 참조하는지 그리고 세그멘트의 오프셋은 얼마인지 알기 위해, 가상 주소의 최상위 비트 일부를 세그멘트의 종류를 나타내는데 사용한다. 위와 같은 3개의 세그멘트로 나뉘어진 경우 2비트가 필요하게 된다. 만약 최상위 2비트가 00일 경우, 하드웨어는 가상 주소가 코드 세그멘트를 가리킨다는 것을 알게 되고, 01이면 힙 세그멘트임을 알게 된다. 힙에 해당하는 가상 주소(4200)은 아래와 같은 형식을 이진 형식을 가질 것이다:

```
 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| 0  1  0  0  0  0  0  1  1  0  1  0  0  0|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
segment               offset

virtual address: 2^12 + 2^6 + 2^5 + 2^3 = 4200
offset: [0000 0110 1000] = 0x068 or 104
```
<br />
최상위 2비트는 하드웨어에게 참조하는 세그멘트의 종류를 알려주고, 하위 12비트는 세그멘트의 오프셋을 나타낸다. 하드웨어는 오프셋에 베이스 레지스터 값을 더하여 최종 물리 주소를 계산한다. 오프셋은 바운드 검사도 쉽게 만드는데, 오프셋이 바운드보다 작은지 여부만 검사하면 되기 때문이다.

위의 경우, 3개의 세그멘트를 가정하였기 때문에, 하나의 세그멘트가 미사용으로 남게 되는데, 이는 전체 주소 공간의 1/4는 사용이 불가능함을 의미한다. 일부 시스템은 가상 주소 공간을 모두 활용하기 위해 코드와 힙을 하나의 세그멘트에 저장하고, 세그멘트 선택을 위해 1비트만 사용하기도 한다. 또한 상위 몇 비트를 세그멘트 선택에 사용하는 것은 또 다른 문제가 있는데, 바로 가상 주소 공간의 활용도를 제한한다는 것이다. 상위 2비트를 사용한다는 말은 16KB 주소 공간이 4개의 조각으로, 즉 4KB로 나뉜다는 것을 의미한다. 실행 중인 프로그은이 세그멘트의 크기를 최대 크기 이상(4KB)으로 증가시킬 수 없다. 그렇기에 최상위 비트 외에도 **묵시적(implicit)**인 접근 방식으로 세그멘트를 결정할 수도 있다(주소가 어떠한 작동 형태를 가지는지에 따라 세그멘트를 분류한다).

### 스택
위에서 프로그램 코드와 힙은 주소공간의 확장이 아래에서 위로(즉 순차적으로) 진행되는 반면, 스택은 위에서 아래로(즉 반대 방향으로) 확장되기에, 다른 세그멘트들과는 별도의 변환이 필요하게 된다. 이를 위해선 세그먼트가 어느 방향으로 확장되는지를 표시하는 간단한 하드웨어가 추가로 필요하게 된다. 가령 하나의 비트를 사용하여 주소가 양의 방향으로 확장하면 1, 음의 방향으로 확장하면 0으로 표시할 수 있다.

```
segment    base    size    direction
------------------------------------
 code      32KB     2KB       1
 heap      34KB     3KB       1
stack      28KB     2KB       0
```
<br />
스택의 주소 공간의 주소 변환 과정은 다음과 같다:
1. 가상 주소 15KB을 참조하는 경우, 해당 가상 주소를 이진 형태로 변환하면 `[11 1100 0000 0000]`이 되는데, 하드웨어는 상위 2비트 (11)을 사용하여 스택 세그멘트임을 인지하고, 남은 `[1100 0000 0000]`, 즉 3KB를 _오프셋_으로 삼는다. 하지만 올바른 _음수 오프셋_을 얻기 위해선 해당 오프셋에서 세그멘트 최대 크기를 빼야 하는데, 따라서 이 경우 올바른 오프셋은 3KB - 4KB = -1KB가 되고, 이 음수 오프셋(-1KB)을 베이스(28KB)에 더하여, 올바른 물리주소 27KB를 얻게 된다. 음수 오프셋의 절댓값이 세그멘트의 현재 크기보다 작거나 같음을 확인하여(스택의 경우 2KB) 바운드 검사를 할 수 있다.

### 공유 지원

세그멘테이션 기법이 발전함에 따라 간단한 하드웨어 지원을 이용한 효율성을 만들어내고자 하였다. 그 중 메모리를 절약하기 위해 주소 공간들 간에 특정 메모리 세그멘트를 **공유**하는 방법이 등장하였다(특히 **코드 공유**가 일반적이다). 공유를 지원하기 위해선 하드웨어에 **protection bit**의 추가가 필요한데, 하드웨어는 protection bit를 확인하여 해당 세그멘트를 읽거나 쓸 수 있는지 혹은 코드를 실행시킬 수 있는지를 알게 된다.코드 세그멘트를 읽기 전용으로 설정하면 주소 공간의 독립성을 유지하면서도 여러 프로세스가 주소 공간의 일부를 공유할 수 있다(여러 가상 주소 공간에 매핑될 수 있다). protection bit를 사용하게 될 경우, 앞선 알고리즘에 가상 주소가 범위 내에 있는지 확인하는 것 외에도 특정 액세서가 허용되는지 확인하는 과정을 추가해야 할 것이다.

### 소단위 대 대단위 세그멘테이션

위의 예제는 소수의 세그멘트(즉 코드, 스택, 힙)만을 지원하는 시스템에 초점을 맞춘다. 이를 **대단위(coarse-grained)** 세그멘테이션이라고 말한다. 하지만 반대로 주소 공간을 작은 크기의 공간으로 잘게 나누는 **소단위(fine-grained)** 세그멘테이션 또한 가능하다. 많은 수의 세그멘트를 지원하기 위해선 여러 세그멘트의 정보를 메모리에 저장할 수 있는 **세그멘트 테이블**과 같은 하드웨어가 필요하게 된다.

### 세그멘테이션을 위한 운영체제의 지원

세그멘테이션의 도입을 위해선 운영체제가 해결해야 하는 몇 가지 문제가 있다:
1. 문맥교환. 세그멘테이션을 사용하면서 문맥 교환을 해야한다면, 운영체제는 세그멘트 레지스터의 저장과 복원을 지원해야 한다.
2. 세그멘트 크기의 변경. 가령 프로그램이 `malloc()`을 호출하여 객체를 할당할 경우, 빈 공간을 할당해주거나 빈 공간이 없을 경우 힙 세그멘트의 크기를 증가시킴으로써(이 경우 시스템 콜을 호출함으로써 세그멘트 크기 레지스터를 새로운 크기로 갱신해야 한다) 새로운 객체에 공간을 할당하고 포인터를 반환해야 한다.
3. 미사용 중인 물리메모리 공간의 관리. 운영체제는 새로운 주소 공간의 세그멘트를 위한 비어있는 물리 메모리 영역을 찾아야 한다.

<br />
운영체제에 생길 수 있는 문제는 일반적으로 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다는 것이다. 그러한 공간들은 새로 생겨나는 세그멘트를 배치하는데 어려움을 줄 뿐만 아니라, 기존 세그멘트의 확장도 방해하게 된다. 이를 **외부 단편화(external fragmentation)**라고 부른다. 이 문제의 해결책 중 한 가지는 기존의 세그멘트를 정리하여 물리 메모리를 **압축(compact)**하는 것인데, 압축을 위한 세그멘트 복사는 메모리에 부하를 주고 시간이 오래 걸리는 큰 연산이기 때문에, 비용이 많이 든다. 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘을 사용하는 것이다(**최적 적합(best-fit)**, **최악 적합(worst-fit)**, **최초 적합(first-fit)** 및 **버디 알고리즘(buddy algorithm)** ...). 하지만 이러한 알고리즘을 적용하더라도 여전히 외부 단편화는 일어날 수밖에 없다. (왜냐하면 외부 단편화 문제는 가변 길이 할당의 태생적인 문제이기 때문에 회피하기 어렵다.)

세그멘테이션은 주소 공간 사이의 공간 낭비를 피함으로써 효율적이고, 하드웨어 구현도 어렵지 않기에 속도도 빠르며, 변환 오버헤드도 최소이고, 코드 공유의 장점도 부가적으로 발생한다. 하지만 세그멘트의 크기가 일정하지 않기에 몇 가지 문제가 발생하는데, 하나는 위와 같은 외부 단편화이고, 다른 하나는 세그멘테이션이 _아직_ 드문드문 사용되는 주소 공간(sparse address space)을 지원할만큼 충분히 유연하지 못하다는 점이다. 가령 크기가 크지만 드문드문 사용되는 힙은 여전히 힙 전체가 물리 메모리에 존재해야 한다. 즉 주소 공간이 실제로 사용되는 방법과 세그멘테이션의 설계 방법이 다르기에 문제가 생길 수 있다.

