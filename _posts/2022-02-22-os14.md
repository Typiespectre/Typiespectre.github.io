---
title: "OSTEP - 가상화: 페이징 - 더 작은 테이블"
lang: "ko"
layout: post
date: 2022-02-22 23:05:48 +0900
ategories: [os]
tags: [os]
---

선형 페이지 테이블(linear page table)의 단점은, 페이지 테이블이 커질수록 많은 메모리 공간을 차지하게 된다는 점이다. 이를 해결할 수 있는 방법은 여러 가지가 있을 수 있다. 가령, 간단하게는 페이지 크기를 증가시키면 된다. 예를 들어, 페이지 크기가 4KB이고, 페이지 테이블의 각 항목은 4바이트인 32비트 주소 공간이라면, `2^20*4바이트`만큼의 크기를 갖게 되지만, 페이지 크기가 16KB라면 `2^18*4바이트`로, 페이지 크기가 1/4로 감소하게 된다.하지만 페이지 크기의 증가는 **내부 단편화(internal fragmentation)**문제를 가진다. 즉 페이지 _내부의_ 낭비 공간이 증가하여, 컴퓨터 시스템의 메모리가 금방 고갈될 수 있다. 그렇기에 많은 컴퓨터 시스템들이 일반적으로 4KB와 8KB와 같은 작은 페이지를 사용한다.

페이징과 세그멘테이션을 결합한 **하이브리드(hybrid)**적인 접근 방식도 존재한다. 이는 프로세스의 전체 공간에 하나의 페이지 테이블을 두지 않고, 논리 세그멘트(코드, 힙, 스택 등)마다 따로 페이지 테이블을 두는 것이다. 세그멘테이션에서 보았듯이, 세그멘트에는 물리 주소 시작 위치를 나타내는 **베이스(base)** 레지스터와 크기를 나타내는 **바운드(bound)** 또는 **리미트(limit)** 레지스터가 존재한다. 이 경우에도 비슷하게, 베이스 레지스터는 _페이지 테이블의 시작 물리 주소_를 나타내고, 바운드 레지스터는 페이지 테이블의 끝을 나타낸다. 가상 주소 공간은 소속 세그멘트를 나타내기 위해 상위의 비트들을 사용한다. 

하이브리드 기법의 핵심은, 세그멘트마다 바운드 레지스터가 따로 존재한다는 것이다. 각 바운드 레지스터의 값은 세그멘트의 최대 유효 페이지의 개수를 나타낸다. 만약 코드 세그멘트가 세 개의 페이지를 사용한다면, 코드 세그멘트의 바운드 레지스터는 3으로 설정되고, 범위가 넘어가는 메모리 접근은 예외를 발생시킨다. 이는 스택과 힙 사이의 할당되지 않은 페이지에 공간을 할당하지 않음으로써, 메모리 사용을 개선시킬 수 있다. 그러나 여전히 세그멘테이션 기법을 사용함으로써, 빈 공간이 많은(sparsely used) 힙에 대해선 페이지 테이블의 낭비를 가져오게 되고, 하이브리드 기법은 외부 단편화를 유발한다. 왜냐하면 하이브리드 방식에서는 페이지 테이블 크기에 제한이 없기에, 다양한 크기를 갖기 때문이다.

# 멀티 레벨 페이지 테이블

**멀티 레벨 페이지 테이블**은 선형 페이지 테이블을 트리 구조로 표현함으로써 페이지 테이블의 크기를 줄인다. 이 방식은 매우 효율적이기에 많은 현대 시스템에서도 사용되고 있다고 한다. 멀티 레벨 페이지 테이블의 기본적인 개념은 다음과 같다:

- 페이지 테이블을 페이지 크기의 단위로 나눈다. 페이지 테이블의 페이지가 유효하지 않은 항목만 있으면, 해당 페이지를 할당하지 않는다.
- **페이지 디렉터리(page directory)**라는 자료 구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다. (페이지 디렉터리는 페이지 테이블을 구성하는 각 페이지의 존재 여부와 위치 정보를 가지고 있다.)
<br />
<br />

페이지 디렉터리를 이용하면 페이지 테이블의 어떤 페이지들이 할당되었는지를 알 수 있다. 페이지 디렉터리는 페이지 테이블의 한 페이지를 나타내는 **페이지 디렉터리 항목(page directory entries, PDE)**로 구성된다. PDE의 구성은 페이지 테이블의 각 항목(page table entry, PTE)과 유사하며, **유효(valid)** 비트와 **페이지 프레임 번호(page frame number, PFN)**을 갖고 있다. 

멀티 레벨 페이지 테이블은 위에서 언급된 기법들에 비해 몇 가지 장점을 갖는다. 먼저, 멀티 레벨 페이지 테이블은 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당되므로, 보다 작은 크기의 페이지 테이블로 주소 공간을 표현할 수 있다. 그리고 멀티 레벨 페이지 테이블은 페이지 테이블을 페이지 크기로 분할함으로써, 메모리 관리를 용이하게 한다. 멀티 레벨 페이징에서는 페이지 디렉터리를 이용하여 각 페이지 테이블의 페이지들의 위치를 파악하기에, 각 페이지들이 물리 메모리에 산재해 있더라도 그 위치를 쉽게 파악할 수 있어, 유연한 공간 할당을 가능하게 하기 때문이다.

하지만 멀티 레벨 페이징에는 추가 비용이 발생한다. TLB 미스 시, 주소 변환을 위해 페이지 디렉터리와 PTE 접근을 위해 각각 한번씩, 총 두 번의 메모리 로드가 발생한다. 그렇기에 멀티 레벨 페이지 테이블은 시간(페이지 테이블 접근 시간)과 공간(페이지 테이블 공간)을 상호 절충(time-space-trade-offs)한 예라고 할 수 있다. 또 하나의 단점은 _복잡도_이다. 페이지 테이블 검색이 단순 선형 페이지 테이블의 경우보다 더 복잡해지기 때문이다.

멀티 레벨 페이지 테이블의 예제를 살펴보자. 64바이트 페이지를 갖는 16KB 크기의 주소 공간(따라서 14비트 가상 주소가 요구되며, VPN에 8비트, 페이지 오프셋에 6비트가 할당된다)이 있다고 가정한다. 선형 페이지 테이블은 2^8개의 엔트리로 구성된다. 그리고 가상 페이지 0과 1은 코드, 가상 페이지 4와 5는 힙 그리고 가상 페이지 254와 255는 스택으로 사용된다고 가정한다. 나머지 공간은 미사용이다.
```
0000 0000 |   code   |
0000 0001 |   code   |
0000 0010 |  (free)  |
0000 0011 |  (free)  |
0000 0100 |   heap   |
0000 0101 |   heap   |
0000 0110 |  (free)  |
...
1111 1101 |  (free)  |
1111 1110 |   stack  |
1111 1111 |   stack  |

그림: 64바이트 페이지들로 이루어진 16KB 주소 공간
```
<br />

위 예제의 주소 공간을 2단계 페이지 테이블로 구성하기 위해선, 먼저 선형 페이지 테이블을 페이지 단위로 분할한다. 전체 테이블은 256(2^8)개의 항목을 가지고 있고, 각 PTE가 4바이트라고 가정하면, 페이지 테이블의 크기는 1KB가 된다. 그리고 페이지가 64바이트라면, 1KB의 페이지 테이블을 16개의 64바이트 페이지로 분할할 수 있다. 따라서 선형 페이지 테이블은 16개로 나눠지고, 페이지 테이블의 상태를 가지는 페이지 디렉터리는 16개의 PTE를 갖는다. 따라서 VPN의 상위 4비트를 페이지 디렉터리 인덱스로 사용하고, VPN의 나머지 비트를 페이지 테이블 인덱스로 사용한다.

```
           VPN                  offset     
+-----------------------+-----------------+
|13|12|11|10|09|08|07|06|05|04|03|02|01|00|
+-----------+-----------+
     PDI         PTI     
```
<br />


