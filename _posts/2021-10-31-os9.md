---
title: "OSTEP - 가상화: 메모리 관리 API"
lang: "ko"
layout: post
date: 2021-10-31 15:20:54 +0900
categories: [os]
tags: [os]
---
이번 장에서는 C언어의 메모리 관리 API에 대해서 간단하게 배운다. 메모리 관리 API를 이용하여 메모리의 사용자 주소 공간을 할당하거나 해제할 수 있다. 이러한 할당과 해제에 필요한 API는 무엇이고, 어떠한 실수가 발생할 수 있을까?

우선 C프로그램이 실행되면 두 가지 유형의 메모리 공간이 생성된다. 하나는 스택(stack)메모리라고 불리며, 할당과 반환은 컴파일러에 의해 _암묵적으로_ 이루어지기에, **자동(automatic)** 메모리라고 불리기도 한다. C프로그램에서 스택에 메모리를 선언하는 방식은 다음과 같다:
```c
// func()라는 함수에 x라 불리는 정수를 위한 공간이 필요한 경우
void func() {
    int x; // 스택에 int 형을 선언
    ...
}
```
<br />
함수가 호출되면 컴파일러는 스택에 공간을 확보한다. 함수에서 리턴하면 컴파일러는 사용자를 대신해 메모리를 반환한다.

다른 하나는 힙(heap) 메모리라고 불리며, 모든 할당과 반환이 사용자에 의해 명시적으로 처리된다. 위의 스택 메모리는 컴파일러가 자동으로 메모리를 할당하고 반환하기에, 힙 메모리를 이용하면 원하는 값을 원하는 시간만큼 유지할 수 있다. 이러한 권한만큼 다양한 오류가 생성되는 원인이기도 하다. C프로그램에서 힙에 할당하는 방식은 다음과 같다:
```c
void func() {
    int *x = (int *) malloc(sizeof(int));
    ...
}
```
<br />

위의 코드에서 짚고 넘어가야 할 점들이 있다. 위의 코드에서는 스택과 힙 할당이 모두 발생하는데, 먼저 컴파일러가 포인터 변수의 선언(`int *x`)를 만나 정수 포인터를 위한 공간을 할당해야 함을 알아차리게 된다. 그리고 프로그램이 `malloc()`을 호출하여 정수를 위한 공간을 힙으로부터 요구한다. 이후 `malloc()`은 그 정수의 주소를 반환한다(만약 반환에 실패하면 NULL을 반환한다). 반환된 주소는 스택에 저장되어 프로그램에 의해 사용된다.

## `malloc()` 함수

힙 메모리의 할당을 수행하는 `malloc()`함수에 대해 알아보자. `malloc()`함수에 힙에 요청할 공간의 크기를 넘겨주면, 성공했을 경우 새로 할당된 공간에 대한 포인터를 사용자에게 반환하고, 실패했을 경우 NULL을 반환한다. `malloc()`의 호출은 아래와 같다:
```c
#include <stdlib.h>
...
void *malloc(size_t size);
```
<br />

`malloc()`을 사용하기 위해 반드시 헤더 파일을 붙이지 않아도 되지만, 헤더 파일을 추가하면 `malloc()`의 호출의 유효성을 컴파일러가 검사할 수 있다. `malloc()`의 인자는 `size_t` 타입의 변수이고, 이 변수는 필요 공간의 크기를 바이트 단위로 표시한 것이다. 많은 사용자가 `malloc(10)`처럼 숫자를 직접 입력하는 경우가 많은데, 그러한 방식으로 입력하는 것보단 다양한 루틴과 매크로를 통한 입력이 권유된다. 아래는 `double precision`의 부동 소수점 값을 위한 공간을 확보하는 코드이다:
```c
double *d = (double *) malloc(sizeof(double));
```
<br />

위의 코드에서는 `malloc()`에 정확한 크기의 공간을 요청하기 위해 `sizeof()` 연산자를 사용하였다. `sizeof()`의 인자의 실제 크기는 컴파일 시간에 결정되기에, `sizeof()`는 숫자(이 경우 `double`의 크기인 8)로 대체되어 `malloc()`에 전달된다. 데이터 타입 외에도 변수의 이름도 `sizeof()`의 인자로 전달할 수 있는데, 원하는 결과가 나오지 않을 수도 있다. 아래의 첫 번째 코드에선 동적으로 할당받은 메모리의 크기가 아닌 정수를 가리키는 포인터의 크기가 출력되고, 두 번째 코드에선, 할당받은 메모리의 크기가 정상적으로 출력된다. 이 둘의 차이는 컴파일러가 알 수 있는 정보가 충분한가 아닌가에 따라 나뉘게 되는 것이다:
```c
//1
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x)); // 4 또는 8

//2
int x[10];
printf(%d\n", sizeof(x)); // 40
```
<br />

