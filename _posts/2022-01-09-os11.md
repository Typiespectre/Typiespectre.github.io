---
title: "OSTEP - 가상화: 세그멘테이션"
lang: "ko"
layout: post
date: 2022-01-09 20:37:54 +0900
categories: [os]
tags: [os]
---
이전의 베이스-바운드 방식의 단점은, 간단한 구현이 가능함에도 불구하고 스택과 힙 사이에 사용되지 않는 공간이 그대로 남아있게 된다는 점이다. 즉 유연성이 떨어지기에 메모리 낭비가 심하고, 주소 공간이 물리 메모리보다 큰 경우 실행이 어렵게 된다.이 문제를 해결하기 위해 **세그멘테이션(segmentation)**이라는 아이디어가 등장했다.

세그멘테이션을 적용할 경우 **세그멘트(segment)**의 개수만큼 MMU에 베이스와 바운드값이 존재하게 된다. 세그멘트는 특정 길이를 가지는 연속적인 주소 공간으로(교재의 주소 공간의 경우, 코드와 스택 및 힙의 세 종류의 세그멘트가 있다), 세그멘테이션을 사용하면 운영체제는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있게 되어, 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있다.

```
 0KB +------------+           0KB +------------+
 1KB |program code|               |     OS     |
 2KB +------------+          16KB +------------+
 3KB |            |               |  (unused)  |
 4KB +------------+               +------------+
 5KB |            |               |   stack    |
 6KB |    heap    |          32KB +------------+
 7KB +------------+               |program code|
 8KB |            |               +------------+
 ...                              |    heap    |
14KB +------------+          48KB +------------+
15KB |   stack    |               |  (unused)  |
16KB +------------+          64KB +------------+

    <address space>             <physical memory>

그림 1. 주소 공간과 세그멘트가 배치된 물리 메모리
```
<br />
그림 1을 보면, 사용 중인 메모리에만 물리 공간이 할당되어, 사용되지 않은 영역이 많은 대형 주소 공간(**드문드문 사용되는 주소 공간(sparse address space)**)을 수용할 수 있다. 이 경우, 세 쌍의 베이스와 바운드 레지스터 집합을 담을 수 있는 MMU 하드웨어 구조가 필요하다. 각 바운드 레지스터는 세그멘트의 크기를 저장한다.

```
segment    base    size
-----------------------
 code      32KB     2KB
 heap      34KB     3KB
stack      28KB     2KB

그림 2. 세그멘트 레지스터의 값
```
<br />

