---
title: "OSTEP - 가상화: 페이징 - 더 빠른 변환(TLB)"
lang: "ko"
layout: post
date: 2022-02-10 20:04:30 +0900
categories: [os]
tags: [os]
---

앞서 보았듯이, 운영체제가 페이징 기법을 적용하기 위해선 페이지 매핑 정보를 저장하기 위한 메모리 공간이 요구된다. 그리고 가상주소에서 물리주소로 변환을 하기 위해선 메모리에 존재하는 매핑 정보를 읽기 위한 메모리 접근이 발생하고, 이는 커다란 성능 저하를 가져올 수 있다. 운영체제는 실행 속도의 개선을 위해 하드웨어를 사용할 수 있다. 그리고 운영체제는 주소 변환을 빠르게 하기 위해 **변환-색인 버퍼(translation-lookaside buffer, TLB)**라고 불리우는, 칩의 **메모리 관리부(memory-management unit, MMU)**의 일부를 사용한다. TLB는 자주 참조되는 가상주소와 물리주소의 변환 정보를 저장하는 하드웨어 캐시이다. 가상 메모리를 참조하는 경우, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지 확인하고, 만약 있다면 (메모리 상에서 모든 변환 정보를 갖고 있는) 페이지 테이블에 접근하지 않고 변환을 빠르게 수행할 수 있다. 따라서 TLB는 페이징 성능을 향상시킨다.

## TLB 개요

TLB의 기본 알고리즘은 다음과 같다:
1) 가상주소에서 가상 페이지 번호(virtual page number, VPN)을 추출한 후, 해당 VPN의 TLB 존재 여부를 검사한다.
2) 만약 존재하면 TLB가 변환 값을 갖고 있다는 뜻이므로, **TLB 히트**이다.
2-1) TLB 히트일 경우, 해당 TLB 항목에서 페이지 프레임 번호(page frame number, PFN)를 추출한다. 먼저 해당 페이지에 대한 접근 권한 검사를 하고, 해당 페이지의 정보를 원래의 가상주소의 오프셋과 합쳐 원하는 물리주소를 구성하고, 메모리에 접근한다.
3) 만약 존재하지 않는다면, **TLB 미스**이다.
3-1) TLB 미스일 경우, 먼저 하드웨어가 변환 정보를 찾기 위해 페이지 테이블에 접근한다.
3-2) 프로세스가 생성한 가상 메모리 참조의 유효성을 확인한 후, 해당 페이지 정보를 TLB로 읽어들인다. 페이지 테이블 접근을 위한 메모리 참고로 인해 시간이 많이 소요된다.
3-3) TLB가 갱신되면 하드웨어는 명령어를 재실행한다.
3-4) 이번에는 TLB에 변환 정보가 존재함으로, 메모리 참조가 빠르게 처리된다.

TLB는 프로세싱 코어와 가까운 곳에 위치하고, 매우 빠른 하드웨어로 만들어져, TLB 히트가 발생하면 주소 변환 작업은 아주 빠르게 이루어진다. 하지만 TLB 미스가 발생하면 메모리 참조 과정이 추가되므로, 페이징 비용이 커진다. 메모리 접근 연산은 다른 CPU 연산에 비해 매우 시간이 오래 걸린다.

다음과 같은 예제를 생각해볼 수 있다: 가상 주소 100번지부터 10개의 4바이트 크기의 정수 배열이 존재한다고 가정하자. 각 가상 주소 공간은 8비트이며, 페이지 크기는 16바이트이다. 가상주소는 4비트 VPN(16개의 가상 페이지들을 표현)과 4비트 오프셋(각 페이지는 16바이트 크기를 가짐)으로 구성된다. 배열은 크기가 16바이트인 16개의 페이지로 구성된 가상 주소 공간에 다음과 같이 그려질 것이다.

```
                      offset
         0      04      08      12      16
         +------------------------------+
VPN = 01 |                              |
         +------------------------------+
VPN = 02 |             ...              |

         +------+-------+-------+-------+
VPN = 06 |      | a[0]  | a[1]  | a[2]  |
         +------+-------+-------+-------+
VPN = 07 | a[3] | a[4]  | a[5]  | a[6]  |
         +------+-------+-------+-------+
VPN = 08 | a[7] | a[8]  | a[9]  |       |
         +------+-------+-------+-------+
VPN = 09 |             ...              |

VPN = 15 |                              |
         +==============================+
```
<br />

TLB가 완전히 초기화되었다고 가정하면, 첫 번째 a[0] 배열 접근은 당연히 TLB 미스가 일어난다. 하드웨어는 가상주소에서 VPN을 추출하여 해당 VPN에 대한 물리 페이지 번호를 찾아 TLB를 갱신한다. 다음 배열 a[1]은 TLB 히트가 발생한다. 왜냐하면 a[1] 배열은 a[0] 배열과 같은 페이지에 존재하기 때문이다. _첫 번째 배열 항목을 읽을 때, 이미 해당 페이지를 접근하였기 때문에, 필요한 변환 정보가 이미 TLB에 탑재되어 있다._ 동일하게 a[3] 배열을 읽을 때는 미스가 발생하지만, a[4], a[5], a[6]을 읽을 때는 히트가 발생한다. 결과적으로 <미스 - 히트 - 히트 - 미스 - 히트 - 히트 - 히트 - 미스 - 히트 - 히트>로 TLB는 동작하게 된다.

위처럼, TLB는 **공간 지역성(spatial locality)**으로 성능이 개선될 수 있다. 배열의 항목들이 페이지 내에서 서로 인접해 있다면, 하나의 미스로 다수의 히트를 이루어낼 수 있다. 또한 페이지 크기는 TLB의 효용성에 중요한 역할을 한다. 만약 페이지 크기가 두 배가 되면(16이 아니라 32바이트), 위와 같은 연속적인 정수 배열 접근의 경우, 성능이 훨씬 개선될 것이다. 그리고 프로그램이 루프 종료 후에도 배열을 사용한다면 성능은 더욱 개선될 수 있다. 왜냐하면 모든 주소 변환 정보가 TLB에 탑재되어 있기 때문이다. 이는 **시간 지역성(temporal locality)**으로 TLB의 성능이 개선되는 것으로 볼 수 있다. 시간 지역성이란, 한번 참조된 메모리 영역이 짧은 시간 내에 재 참조되는 현상을 일컫는다.

따라서 TLB는 캐시 사용과 마찬가지로, 공간 지역성과 시간 지역성을 최대한 활용하는 것이 관건이다. 그렇다면 초대용량 TLB를 만들면 모든게 해결되지 않을까? 하지만 단순하게 답을 내린다면, 빠르게 하려면 크기가 작아야 한다고...

## TLB 미스는 누가 처리할까?

TLB 미스의 처리는 하드웨어와 소프트웨어로 나눠진다. **CISC(complex-instruction set computing)**기반 컴퓨터는 TLB 미스를 하드웨어가 처리하도록 설계했다. 인텔 x86 CPU가 하드웨어로 관리되는 TLB의 대표적인 예이다. 이를 위해선 하드웨어가 페이지 테이블에 대한 명확한 정보와 메모리 상 위치 그리고 정확한 형식을 파악하고 있어야 한다. **RISC(reduced instruction set computing)** 기반 컴퓨터는 TLB 미스를 운영체제가 처리하도록 설계한다. MIPS나 SPARC이 RISC의 대표적인 예이다. 만약 TLB 미스가 발생하면, 하드웨어는 예외(exception) 시그널을 발생시키고, 운영체제는 명령어 실행을 잠정 중지하고 실행 모드의 특권 레벨(privilege level)을 상향 조정하여 커널 모드로 변경한다. 커널 모드로 변경이 되면 TLB 미스의 처리를 담당하는 **트랩 핸들러(trap handler)**를 실행한다. 트랩 핸들러는 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 특권 명령어를 사용하여 TLB를 갱신한 후, 트랩 핸들러에서 리턴한다. 이후 하드웨어는 명령어를 재실행한다.
    - CISC의 설계 배경은 어셈블리어 명령어로 상위 수준 작업을 실행하고, 코딩을 쉽게 하며, 코드를 간단하게 하는 데 있다. CISC 명령어 집합은 많은 수의 명령어로 구성되어 있으며, 각 명령들은 강력한 기능을 가지는 것이 특징이다. 반면 RISC는 명령어 집합을 작고 간단하게 설계하여, 즉 최대한 단순한 하드웨어를 추구한다. RISC의 컴파일러는 몇 가지의 단순한 어셈블리 명령어만 있으면 고성능의 코드를 생성해 낼 수 있다.

두 가지 중요한 사항이 있다. 먼저, TPB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와 다르다. 시스템 콜 호출의 트랩 핸들러는, 리턴 후 시스템 콜을 호출한 명령어의 "다음" 명령어를 실행한다. TLB 미스 처리의 경우, 트랩에서 리턴하면 _트랩을 발생시킨 명령을 "다시" 실행하여_ TLB 히트를 발생시킨다. 트랩이 발생하면 운영체제는 트랩 핸들러가 종료되었을 때 다시 되돌아올 명령어 주소(Program Counter 값)을 저장해야 하는데, 따라서 운영체제는 트랩 발생의 원인에 따라 저장해야 하는 PC값이 다르다. 두 번째로, TLB 미스가 무한 반복하지 않도록 트랩 핸들러를 다뤄야 한다. 즉, TLB 미스 핸들러를 접근하는 과정에서 TLB 미스가 발생하는 것이다. 이를 해결하기 위한 방법 중, TLB 미스 핸들러를 물리 메모리에 위치시킴으로써 주소 변환을 할 필요가 없게 만들 수 있거나, TLB의 일부를 핸들러 코드 전용으로 영구 할당 함으로써, 언제든 핸들러는 TLB 히트가 일어나게 만들 수 있다 - 이를 **연결(wired)** 변환이라 한다. TLB를 소프트웨어로 관리하는 방식의 장점은 _유연성_과 _단순성_이다. 운영체제는 하드웨어 변경 없이 페이지 테이블 구조를 자유롭게 변경할 수 있고, 하드웨어에게 커다란 일을 하지 않도록 돕는다.

## TLB의 구성

TLB는 일반적으로 32, 64 또는 128개의 엔트리를 가지며, **완전 연관(fully associative)** 방식으로 설계된다. 완전 연관 방식으로 인해 변환 정보는 TLB내에 어디든 위치할 수 있고, 원하는 변환 정보를 찾는 검색은 TLB 전체에서 병렬적으로 수행된다. 즉, 하드웨어는 TLB의 각 항목들을 동시에 검색한다.  TLB 구성은 아래와 같다:

```
VPN   |   PFN   |   다른 비트들
```
<br />

다른 비트들로, 특정 항목이 유효한 변환 정보를 갖고 있는지의 여부를 나타내는 **유효(valid) bit**와, 페이지 접근을 통제하는 **보호(protection) bit**가 있다. 이외에도 **주소 공간 식별자(address-space identifier, ASID), 더티 비트(dirty bit)** 등이 있다. TLB를 사용하게 되면 프로세스 간 문맥 교환 시 새로운 문제가 발생한다. 왜냐하면 TLB에 있는 가상주소와 물리주소 간의 변환 정보는 해당 프로세스에서만 유효하지, 다른 프로세스에는 적용되선 안되기 때문이다. 예를 들어, 두 개의 프로세스의 VPN이 10으로 동일하고, 이 두 정보가 모두 TLB에 탑재되어 있다면, 각 프로세스의 가상 페이지를 구별할 방법이 없다. 이를 위한 한 가지 방법으로, 문맥 교환이 수행될 경우 다음 프로세스가 실행되기 전에 TLB를 비우는 방법이 있는데, 이를 위해선 모든 valid bit를 0으로 설정해야 한다. 이는 잘못된 변환 정보의 사용을 방지할 수 있지만, 새로운 프로세스가 항상 TLB 미스를 발생시키므로 비용의 부담이 존재한다. 이를 개선하기 위해 TLB 내에 주소 공간 식별자(ASID) 필드를 추가하여, 프로세스 별로 TLB 변환 정보를 구분할 수 있다.

```
VPN   PFN   valid   prot   ASID
-------------------------------
 10   100     1     rwx     1
 --   ---     0     ---     -  
 10   170     1     rwx     2 

 ```
 <br />

 참고로, TLB의 valid bit과 페이지 테이블의 valid bit은 다르다. 페이지 테이블의 valid bit은 해당 페이지 테이블 항목이 프로세스에 할당되지 않았음을 의미한다. TLB의 valid bit은 TLB에 탑재되어 있는 해당 변환 정보가 유효한지를 나타낸다.

 TLB의 **캐시 교체(cache replacement)** 정책은 중요한 문제이다. 한 가지 방법으로, 가장 오래 전부터 사용되었던 **최저 사용 빈도(least-recently-used, LRU)** 항목을 교체하는 것이 있다. LRU는 메모리의 지역성을 최대한 활용하는 것이 목적이다. 왜냐하면 사용된지 오래된 항목일수록, 앞으로도 사용될 가능성이 적기 때문이다. 또 다른 방식은 랜덤(random) 정책이다. 얼핏 보면 LRU보다 랜덤 정책이 더 안좋은 것처럼 보이지만, 랜덤 교체 정책은 구현이 간단하고 예상치 못한 예외 상황을 피할 수 있다. 가령 n개의 변환 정보를 저장할 수 있는 TLB가 n+1개의 페이지들에 대해 반복문을 수행하는 경우, LRU는 항상 TLB 미스를 발생시키는 최악의 결과를 가져오게 된다.

## 실제 TLB

MIPS R4000은 32비트 주소 공간에 4KB 페이지를 지원한다. 19비트의 VPN이 할당되어 있고(20비트가 아닌 이유는, 주소 공간의 절반만 사용자 주소 공간으로 할당되고, 나머지는 커널이 사용하기 때문이다), 24비트의 PFN(물리 프레임 번호)가 할당되어 있다. 따라서 64GB의 물리 메모리(2^24개의 4KB 페이지들) 지원이 가능하다. MIPS는 전역 비트(G), 8비트 길이의 ASID 필드, 일관성 비트(C), 더티 비트, 유효 비트, 페이지 마스크(page mask) 필드 그리고 사용하지 않는 비트들이 들어있다. MIPS의 TLB들은 일반적으로 32개 또는 64개의 항목으로 구성된다. 대부분은 사용자 프로세스들이 사용하지만, 몇 개는 운영체제를 위해 예약되어 있다(가령 TLB 미스 핸들러와 같은 코드와 데이터를 위해). MIPS의 TLB는 소프트웨어가 관리하기 때문에 TLB를 갱신하기 위한 특별한 **실행권한(privileged)**을 가진 명령어들이 필요하다.

```
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                        VPN                          |G |--|--|--|--|          ASID         |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|--|--|                             PFN                                    |   C    |D |V |--|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```
<br />

## 요약

칩 상의 작은 전용 TLB를 주소 변환 캐시로 사용하면 대부분의 메모리 참조들은 메인 메모리 상의 페이지 테이블을 읽지 않고도 처리할 수 있다. 하지만 TLB가 모든 프로그램에서 항상 제대로 작동하는 것은 아닌데, 왜냐하면 프로그램이 짧은 시간 동안 접근하는 페이지들의 수가 TLB에 들어갈 수 있는 수보다 많다면, 그 프로그램은 많은 수의 TLB 미스를 만들게 될 것이기 때문이다. 이러한 현상을 **TLB 범위(TLB coverage)**를 벗어난다고 말한다. 이를 위한 한 가지 해법은 더 큰 페이지 크기를 지원하여 TLB의 유효 범위를 늘리는 것이다. 이러한 해법은 **데이터베이스 관리 시스템(database management system, DBMS)**과 같은 프로그램에서 주요 사용된다. 이러한 프로그램의 자료구조들은 클 뿐만 아니라 _임의적으로_ 접근된다. 또한 **물리적으로 인덱스된 캐시(physically-indexed cache)**가 TLB에 문제가 될 수 있는데, 왜냐하면 주소 변환이 캐시 접근 전에 이루어지기 때문이다. **가상적으로 인덱스된 캐시(virtually-indexed cache)**는 일부 성능 문제를 해결하지만, 새로운 하드웨어 설계 문제를 가져온다.

