---
title: "OSTEP - 가상화: 프로세스의 개념"
lang: "ko"
layout: post
date: 2021-07-18 16:44:25 +0900
categories: [os,]
tags: [os,]
---

(OSTEP의 가상화 파트 중, 프로세스의 개념에 대해 정리하는 글입니다.)

일상에서 컴퓨터를 사용하며 프로그램을 실행하는 순간들은 굉장히 많을 것이다. 지금 VSCode로 글을 쓰는 것도 프로그램의 실행에 의해 가능하게 된 것일터. 하지만 프로그램은 굉장히 단순한 일을 (무지막지하게 빠르고 엄청난 반복횟수로) 할 뿐이다. 바로 명령어를 실행하는 것이다. 프로세서는 프로그램의 명령어를 반입(fetch)하고, 해석(decode)하고, 실행(execute)한다. 하나의 명령어 작업이 끝나면 다음 명령어로, 프로그램이 완전히 종료될 때까지 실행을 계속한다. 이는 Von Neumann 컴퓨팅 모델의 기초적인 부분에 해당되는 이야기이지만, OSTEP은 이러한 모델을 기준으로 이야기를 전개한다.

하지만 단순히 프로그램을 실행하는 것을 가능하게만 한다고 해서 모든 것이 해결되지는 않는다. 프로그램의 실행을 용이하게 하고(더 나아가 동시에 여러 개의 프로그램을 실행하는 것을 가능하게 하고), 프로그램 간의 메모리 공유를 가능하게 하며, 장치와 상호작용을 가능케 하는 등, 다양한 일들을 처리할 수 있는 시스템이 필요하게 되는데, 이를 책임지는 소프트웨어를 **운영체제(operating system, OS)**라고 부른다. 그리고 운영체제는 앞에서 언급한 일을 하기 위하여 **가상화(virtualization)**라고 불리는 기법을 사용한다. 운영체제는 프로세서, 메모리, 또는 디스크와 같은 물리적(physical)인 자원을 이용하여 일반적이고, 강력하고, 사용이 편리한 가상 형태의 자원을 생성한다. 떄문에 운영체제를 때로는 **가상머신(virtual machine)**이라고 부른다.

위에서 프로그램은 단순히 명령어를 실행하는 일을 할 뿐이라고 말했는데, 사실 프로그램 자체는 생명이 없는 존재이다. 프로그램은 보조기억장치(하드디스크, SSD)에 존재하며 실행을 위한 명령어와 정적 데이터(static data, 가령, 초기값을 가지는 변수)의 묶음이다. 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 프로그램은 실행되며, 마치 생명력을 가진듯한 프로그램의 상태를 **프로세스(process)**라고 부른다. 즉 프로세스는 실행 중인 프로그램으로 정의할 수 있다.

누구나 일상에서 컴퓨터를 사용하여 여러 개의 프로그램을 동시에 실행 할 것이다. 여러 프로그램을 동시에 실행할 수 있으면 시스템을 쉽게 사용할 수 있다. 그러나 사실 상 하나의 CPU, 즉 프로세서는 한 순간에 하나의 프로세스만 실행할 수 있다. 하지만 분명히 사용자의 입장에서는, 거의 무한개에 가까운 CPU가 존재하는 것처럼, 여러 개의 프로세스가 한꺼번에 실행되는 것처럼 느껴진다. 그렇다면 CPU는 어떻게 이러한 일을 가능하게 하는 것일까?

CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에, 운영체제는 CPU를 **가상화**하여 사용자로 하여금 여러 개의 프로세스가 한꺼번에 동작하는 듯한 환상을 준다. 운영체제는 **시분할(time sharing)**이라고 불리는 기법을 활용하여 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다. 시분할 기법은 CPU를 공유하기 때문에, 각 프로세스의 성능은 낮아진다. 운영체제의 시분할 기법은 CPU에서 프로그램을 잠시 중단하고 다른 프로그램을 실행하는 문맥 교환(context switch) 메커니즘(mechanism)을 사용한다. 또한 다수의 실행가능한 프로그램 중 어느 프로그램을 선택해서 실행하는지 결정하기 위해 스케쥴링 정책(scheduling policy)을 이용한다.

프로세스의 구성 요소를 이해하기 위해선 **하드웨어 상태(machine state)**를 이해해야 한다. 프로세스의 하드웨어 상태 중 가장 중요한 구성요소는 *메모리*이다. 명령어와 실행 프로그램이 읽고 쓰는 데이터 모두 메모리에 저장된다. 프로세스가 접근할 수 있는 메모리는 **주소 공간(address space)**이라고 불린다. *레지스터* 또한 프로세스의 하드웨어 상태를 구성하는 요소 중 하나이다. 많은 명령어들이 레지스터를 직접 읽거나 갱신한다. 프로세스의 하드웨어 상태를 구성하는 레지스터 중 특별한 레지스터로, 프로그램의 어느 명령어가 실행 중인지 알려주는 프로그램 카운터(program counter, PC)와 함수의 변수와 리턴 주소를 저장하는 스택을 관리하할 때 사용하는 스택 포인터(stack pointer)와 프레임 포인터(frame pointer)가 있다.

운영체제는 사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에 요청할 수 있도록, 사용자에게 API를 제공한다. 운영체제가 반드시 API로 제공해야 하는 기본 기능은 다음과 같다:

- 생성(Create): 새로운 프로세스를 생성한다
- 제거(Destroy): 실행 중인 프로세스를 중단한다.
- 대기(Wait): 어떤 프로세스의 실행 중지를 기다린다.
- 각종 제어(Miscellaneous Control): 프로세스를 일시정지하거나 재개하는 여러 가지 제어 기능들을 제공한다.
- 상태(Status): 프로세스의 상태 정보를 얻는다.\\

앞에서 짚고 넘어가지 않았던 한 가지 미스테리는, 프로그램이 어떻게 프로세스로 변형되는가이다. 운영체제는 어떻게 프로그램을 준비하고 실행시키는가? 실제로 어떻게 프로세스를 생성하는가?

프로그램 실행을 위하여 운영체제가 하는 첫 번째 작업은 명령어(프로그램 코드)와 정적 데이터를 메모리, 프로세스의 주소 공간에 **탑재(load)**하는 것이다. 운영체제는 디스크(보조제어장치)의 해당 바이트를 읽어서 프로그램의 중요 부분을 메모리의 어딘가에 저장해야 한다.

![process1](https://typiespectre.github.io/images/process1.png){: width="90%" height="90%"}

명령어와 정적 데이터가 메모리로 탑재된 후에도 프로세스를 실행하기 위한 절차가 남아있다. 특정 크기의 메모리 공간이 프로그램에 스택(run-time stack, 혹은 그냥 stack) 용도로 할당되어야 한다. 가령, C 프로그램은 지역 변수, 함수 인자, 리턴 주소 등을 저장하기 위해 스택을 사용한다. 운영체제는 스택을 주어진 인지로 초기화한다. 특히, main() 함수의 인자인 argc와 argv 벡터를 사용하여 스택을 초기화한다.

운영체제는 프로그램의 **힙(heap)**을 위한 메모리 영역을 할당한다. C 프로그램에서 힙은 동적으로 할당된 데이터를 저장하기 위해 사용된다. 프로그램은 malloc()을 호출하여 필요한 공간을 요청하고 free()를 호출하여 사용했던 공간을 반환하여 다른 프로그램이 사용할 수 있도록 한다.

운영체제는 또 입출력과 관계된 초기화 작업을 수행한다. 예를 들어, UNIX 시스템에서 각 프로세스는 기본적으로 표준 입력(STDIN), 표준 출력(STDOUT), 표준 에러(STDERR) 장치에 해당하는 세 개의 파일 디스크립터(file descriptor)를 갖는다. 이 디스크립터들을 사용하여 프로그램은 터미널로부터 입력을 읽고 화면에 출력을 프린트하는 작업을 쉽게 할 수 있다.

코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관계된 다른 직업을 마치게 되면, 운영체제는 프로그램 실행을 위한 준비를 마치게 된다. 이후 운영체제는 프로그램을 실행하는 main() 루틴으로 분기함으로써 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작된다.

프로세의 **상태(state)**에 대해 알아보자. 프로세스 상태를 단순화 하면 다음 세 상태 중 하나에 존재할 수 있다.

- 실행(Running): 프로세스가 프로세서에서 실행 중인 상태. 즉, 프로세스는 명령어를 실행하고 있다.
- 준비(Ready): 프로세스가 실행할 준비가 되어있지만 어떠한 이유로 운영체제가 해당 프로세스를 대기하도록 하는 상태.
- 대기(Blocked): 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산. 예를 들어, 프로세스가 디스크에 대한 입출력 요청을 하였을 때 프로세스는 입출력이 완료될 때까지 대기 상태가 되고, 다른 프로세스가 실행 상태로 될 수 있다.\\

![process2](https://typiespectre.github.io/images/process2.png){: width="90%" height="90%"}

프로세스는 운영체제의 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 전이한다. 반대로 실행 상태에서 준비 상태로의 전이는 프로세스가 나중에 다시 스케줄이 될 수 있는 상태가 되었다는 것을 의미한다. 프로세스가 입출력 요청 등의 이유로 대기 상태가 되면 요청 완료 등의 *이벤트*가 발생할 때까지 대기 상태로 유지된다. 이벤트가 발생하면 프로세스는 다시 준비 상태로 전이되고 운영체제의 결정에 따라 바로 다시 실행될 수 있다.

운영체제도 일종의 프로그램이기에, 다른 프로그램들과 같이 다양한 정보를 유지하기 위한 자료구조를 가지고 있다. 예를 들어, 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 **프로세스 리스트(process list)**와 같은 자료 구조를 유지한다. **레지스터 문맥(register context)** 자료구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터값들을 저장한다. 프로세스의 관리를 위한 정보를 저장하는 C 자료구조를 **프로세스 제어 블록(Process Control Block, PCB)**라 부른다.

지금까지 운영체제가 CPU를 가상화하는 방식을 훑어보았다. 앞으로 이를 바탕으로 하여 가상화에 대해 보다 자세히 알아가게 될 것이다.

** 프로세스 관련 주요 용어:
- 프로세스는 실행중인 프로그램을 나타내는 개념이다. 프로세스는 프로세스의 상태, 프로세스 주소공간에 있는 메모리 변수 값들, 레지스터 값들(스택 포인터, 프로그램 카운터 등), 그리고 입출력 관련정보(사용중인 파일들)들로 표현된다.
- 프로세스 API는 프로세스와 관련된 함수들을 일컫는다. 프로세스의 생성, 삭제 등에 관련된 함수들이다.
- 프로세스에는 다양한 프로세스 상태가 있다(실행, 대기, 블럭 등). 특정 사건의 발생(CPU의 할당, CPU의 반납, 입출력 요청, 입출력 완료 등)으로 인해 프로세스의 상태가 변화한다.
- 프로세스 리스트는 시스템에 존재하는 모든 프로세스에 대한 정보를 갖는다. 이 리스트의 각 노드는 프로세스 제어 블록이다.\\
