---
title: "OSTEP - 가상화: 페이징 - 더 작은 테이블"
lang: "ko"
layout: post
date: 2022-02-22 23:05:48 +0900
ategories: [os]
tags: [os]
---

선형 페이지 테이블(linear page table)의 단점은, 페이지 테이블이 커질수록 많은 메모리 공간을 차지하게 된다는 점이다. 이를 해결할 수 있는 방법은 여러 가지가 있을 수 있다. 가령, 간단하게는 페이지 크기를 증가시키면 된다. 예를 들어, 페이지 크기가 4KB이고, 페이지 테이블의 각 항목은 4바이트인 32비트 주소 공간이라면, `2^20*4바이트`만큼의 크기를 갖게 되지만, 페이지 크기가 16KB라면 `2^18*4바이트`로, 페이지 크기가 1/4로 감소하게 된다.하지만 페이지 크기의 증가는 **내부 단편화(internal fragmentation)**문제를 가진다. 즉 페이지 _내부의_ 낭비 공간이 증가하여, 컴퓨터 시스템의 메모리가 금방 고갈될 수 있다. 그렇기에 많은 컴퓨터 시스템들이 일반적으로 4KB와 8KB와 같은 작은 페이지를 사용한다.

페이징과 세그멘테이션을 결합한 **하이브리드(hybrid)**적인 접근 방식도 존재한다. 이는 프로세스의 전체 공간에 하나의 페이지 테이블을 두지 않고, 논리 세그멘트(코드, 힙, 스택 등)마다 따로 페이지 테이블을 두는 것이다. 세그멘테이션에서 보았듯이, 세그멘트에는 물리 주소 시작 위치를 나타내는 **베이스(base)** 레지스터와 크기를 나타내는 **바운드(bound)** 또는 **리미트(limit)** 레지스터가 존재한다. 이 경우에도 비슷하게, 베이스 레지스터는 _페이지 테이블의 시작 물리 주소_를 나타내고, 바운드 레지스터는 페이지 테이블의 끝을 나타낸다. 가상 주소 공간은 소속 세그멘트를 나타내기 위해 상위의 비트들을 사용한다. 

하이브리드 기법의 핵심은, 세그멘트마다 바운드 레지스터가 따로 존재한다는 것이다. 각 바운드 레지스터의 값은 세그멘트의 최대 유효 페이지의 개수를 나타낸다. 만약 코드 세그멘트가 세 개의 페이지를 사용한다면, 코드 세그멘트의 바운드 레지스터는 3으로 설정되고, 범위가 넘어가는 메모리 접근은 예외를 발생시킨다. 이는 스택과 힙 사이의 할당되지 않은 페이지에 공간을 할당하지 않음으로써, 메모리 사용을 개선시킬 수 있다. 그러나 여전히 세그멘테이션 기법을 사용함으로써, 빈 공간이 많은(sparsely used) 힙에 대해선 페이지 테이블의 낭비를 가져오게 되고, 하이브리드 기법은 외부 단편화를 유발한다. 왜냐하면 하이브리드 방식에서는 페이지 테이블 크기에 제한이 없기에, 다양한 크기를 갖기 때문이다.

# 멀티 레벨 페이지 테이블

**멀티 레벨 페이지 테이블**은 선형 페이지 테이블을 트리 구조로 표현함으로써 페이지 테이블의 크기를 줄인다. 이 방식은 매우 효율적이기에 많은 현대 시스템에서도 사용되고 있다고 한다. 멀티 레벨 페이지 테이블의 기본적인 개념은 다음과 같다:

- 페이지 테이블을 페이지 크기의 단위로 나눈다. 페이지 테이블의 페이지가 유효하지 않은 항목만 있으면, 해당 페이지를 할당하지 않는다.
- **페이지 디렉터리(page directory)**라는 자료 구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다. (페이지 디렉터리는 페이지 테이블을 구성하는 각 페이지의 존재 여부와 위치 정보를 가지고 있다.)
<br />

페이지 디렉터리를 이용하면 페이지 테이블의 어떤 페이지들이 할당되었는지를 알 수 있다. 페이지 디렉터리는 페이지 테이블의 한 페이지를 나타내는 **페이지 디렉터리 항목(page directory entries, PDE)**로 구성된다. PDE의 구성은 페이지 테이블의 각 항목(page table entry, PTE)과 유사하며, **유효(valid)** 비트와 **페이지 프레임 번호(page frame number, PFN)**을 갖고 있다.
