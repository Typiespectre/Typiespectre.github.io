---
title: "OSTEP - 가상화: 메모리 크기의 극복: 매커니즘"
lang: "ko"
layout: post
date: 2022-05-11 22:36:23 +0900
categories: [os]
tags: [os]
---

프로세스가 큰 주소 공간을 가진 것처럼 행동하려면, 운영체제는 주소 공간 중 현재는 크게 필요하지 않은 일부를 물리 메모리에서 따로 떼어내 보관해 둘 공간이 필요할 것이다. 또한 멀티프로그래밍(동시에 여러 프로그램들을 실행시키는 시스템)과 사용 편의성 등의 이유로, 실제 물리 메모리보다 더 많은 용량의 메모리가 필요하게 되었다. 이것이 현대 가상 메모리(Virtual Memory)의 역할이며, 현대 시스템에서는 보통 **하드 디스크 드라이브**가 그 역할을 담당한다. 그렇다면 *운영체제는 어떻게 크고 느린 장치를 사용하면서, 마치 커다란 가상 주소 공간이 있는 것처럼 할 수 있을까?* 먼저, (하드 디스크 드라이브와 같은) **스왑 공간(swap space)**이 추가되면, 운영체제는 프로세스로 하여금 큰 가상 메모리가 있는 것 같은 환상을 줄 수 있다.

## 스왑 공간

스왑 공간은 페이지들을 저장할 수 있는 일정 공간을 의미한다. 메모리 페이지를 읽어서 디스크와 같은 공간에 쓰는 것을 *스왑 아웃(swap out)*이라고 하며, 그러한 공간에서 페이지를 읽어 메모리에 탑재하는 것을 *스왑 인(swap in)*이라고 한다. 따라서 운영체제는 스왑 공간에 있는 모든 페이지들의 **디스크 주소**를 기억해야 한다. 스왑 공간을 이용하면, 프로세스에게 물리 메모리 공간보다 더 많은 공간이 존재하는 것처럼 보이게 할 수 있다.

## Present Bit

디스크와 같은 공간에 스왑을 하기 위해선, 페이지 스왑을 위한 기능의 구현이 필요하다(여기선 하드웨어 기반의 TLB를 사용하는 시스템을 가정한다).

* 하드웨어는 먼저 프로세스의 가상 주소에서 VPN을 추출한 후, TLB에 해당 정보가 있는지 검사한다.
	- 만약 **TLB 히트**가 되면, TLB에서 물리 주소를 얻은 후 메모리로 가져온다.
	- 만약 **TLB 미스**(TLB에서 VPN을 찾을 수 없는 경우)가 되면: 1) 하드웨어는 **페이지 테이블 베이스 레지스터**를 사용하여, 페이지 테이블(프로세스의 페이지 정보를 담고 있는 테이블. 하나의 프로세스는 하나의 페이지 테이블을 가진다.)의 메모리 주소를 파악하고, 2) VPN을 인덱스로 하여 원하는 **페이지 테이블 항목(PTE)**를 추출한다. 3) 해당 페이지 테이블 항목이 유효하고, 관련 페이지가 물리 메모리에 존재하면 하드웨어는 PTE에서 PFN 정보를 추출하고, 그 정보를 TLB에 탑재 후, 명령어를 재실행한다. 이후 TLB 히트가 된다.

* 디스크로의 스왑이 가능하기 위해, 하드웨어는 특정한 페이지가 물리 메모리에 존재하는지의 여부를 알아야 하는데, 이를 위해 **present bit**를 사용하여 각 페이지 테이블 항목(PTE)에 어떤 페이지가 존재하는지를 표현한다.
	- present bit가 1로 설정되어 있다면, 물리 메모리에 해당 페이지가 존재한다는 것이고, 0으로 설정되어 있다면, 해당 페이지는 메모리가 아닌 디스크 어딘가에 존재한다는 것을 나타낸다.
	- 물리 메모리에 존재하지 않는 페이지를 접근하는 행위를 일반적으로 **페이지 폴트(page fault)**라 한다.

## 페이지 폴트

페이지 폴트가 발생하면 운영체제의 **페이지 폴트 핸들러(page fault handler)**가 작동한다. 만약 요청된 페이지가 메모리에 없고, 디스크로 스왑되었다면(즉, 페이지 폴트가 발생하였다면) 운영체제는 해당 페이지를 디스크에서 메모리로 스왑해온다. 디스크I/O가 완려되었다면, 운영체제는 해당 페이지 테이블 항목(PTE)의 PFN값을 메모리의 위치로 갱신하고, 그 과정에서 TLB 미스가 발생하지만, 이후 TLB 미스 처리가 이루어짐에 따라 TLB값이 갱신되어, TLB에서 찾은 주소 변환 정보를 이용하여 물리 주소에서 원하는 데이터를 가져온다. 참고로 페이지 폴트 처리 시, 운영체제는 다른 프로세스들을 중첩하여(overlap) 실행할 수 있다.

## 메모리에 빈 공간이 없으면?

만약 스왑한 페이지를 탑재하기 위한 물리 메모리 공간이 부족하다면, 물리 메모리에 들어있던 기존의 페이지를 교체해야 한다. 이를 **페이지 아웃(page out)**이라 하며, 교체 페이지를 선택하는 것을 **페이지 교체 정책(page-replacement policy)**이라고 한다.

## 교체는 실제 언제 일어나는가

메모리에 여유 공간이 고갈되면 교체 알고리즘이 작동하지만, 사실 이는 효율적인 방식이 아니기에 운영체제는 항상 어느 정도의 여유 공간을 확보해놓고자 한다. 대부분의 운영체제들은 여유 공간에 관련된 **최댓값(hign watermark, HW)**과 **최솟값(low watermark, LW)**을 설정하여 교체 알고리즘 작동에 활용하는데, 여유 공간의 크기가 최솟값보다 작아지면, 여유 공간의 크기가 최댓값에 이를 때까지 페이지를 제거하는 방식이다. 이러한 여유 공간 확보를 담당하는 백그라운드 쓰레드는 **스왑 데몬(swap daemon), 페이지 데몬(page daemon)**이라 불린다. 충분한 여유 메모리가 확보되면, 백그라운드 쓰레드는 슬립 모드로 들어간다.

또한 다수의 페이지를 **클러스터(cluster)나 그룹(groups)**으로 묶어 한 번에 스왑을 한다면 디스크의 효율을 높일 수 있다.

-------

이번 장은 물리 메모리의 크기보다 더 많은 메모리를 사용하게 되는 경우, 운영체제가 처리해야 하는 일에 대한 개념의 설명이 주로 이루어졌다. 마지막으로 교재에 나온 한 가지 팁을 적어본다면...

## 백그라운드에서 작업을 하자

어떠한 일을 **백그라운드**에서 처리하고, 여러 가지를 묶어 한 번에 처리하는 것은 효율적일 수 있다. 많은 시스템들은 파일을 쓸 때, 데이터를 디스크에 실제로 쓰기 전에 메모리의 버퍼에 먼저 쓰는데, 이로 인해 디스크가 여러 쓰기 요청을 받지 않기 때문에 디스크의 효율을 높일 수 있고, 응용 프로그램은 쓰기가 빠르게 완료된 것처럼 생각하도록 만들기 때문에 쓰기에 대한 지연 시간이 짧아진다. 또한 디스크로 쓰기가 즉시 전달될 필요가 없기에, 작업량이 줄어들 수도 있다. 백그라운드 작업은 대체로 시스템이 **유휴 상태**에 있을 떄 진행되어, 하드웨어를 더 잘 활용할 수 있게 된다.
