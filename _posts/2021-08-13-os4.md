---
title: "OSTEP - 가상화: 스케줄링 개요"
lang: "ko"
layout: post
date: 2021-08-13 16:54:56 +0900
categories: [os,]
tags: [os,]
---

(OSTEP의 가상화 파트 중, 스케줄링 : 개요에 대해 정리하는 글입니다. 이전에는 책 내용을 맥락에 따라 전반적으로 정리를 했는데, 왠지 너무 길어지게 되는 것 같아, 이번부턴 핵심 내용을 중심으로 짧게 정리해보려고 합니다. 인터넷이나 ppt에서 찾아본 개념도 있기에, 글의 모든 내용이 책에 그대로 서술되어 있는 것은 아닙니다.)

- - -

문맥교환과 같은 저수준 기법을 넘어서, 이번 파트는 운영체제 스케줄러의 고수준 정책에 관하여 이야기한다. 스케줄링의 기원은 컴퓨터가 탄생하기 이전, 생산 관리 분야(Operation Management)에서 시작되었다. 효율적인 생산을 위해 인간의 행동에 스케줄링이 필요하듯, 컴퓨터의 효율적인 프로세스 처리를 위해 운영체제는 스케줄링 정책을 제공한다. 프로세스가 동작하는 일련의 행위를 **워크로드(workload)**라 한다.

스케줄링 정책을 설명하기 앞서, 스케줄링 정책을 보다 쉽게 설명하기 위해 교재는 실행중인 프로세스 혹은 작업(job)에 대해 다음과 같은 이상적인 가정을 한다.

1. 모든 작업은 같은 시간 동안 실행된다.
1. 모든 작업은 동시에 도착한다.
1. 작업은 일단 시작하면 최종적으로 종료될 때까지 실행된다.
1. 모든 작업은 CPU만 사용한다(즉, 입출력을 수행하지 않는다).
1. 각 작업의 실행 시간은 사전에 알려져 있다.
<br />

# 스케줄링의 평가 항목(scheduling metric)

## 반환 시간(turnaround time)    

반환 시간은 작업이 메모리에 들어가기까지 걸린 시간, 준비 큐에 머무르는 시간, 실행 시간, 입출력 시간 등 **작업을 완료하는데 소요되는 시간**이다. 반환 시간은 작업이 완료된 시각에서 작업이 도착한 시간을 뺀 시간으로 계산한다. 공식은 아래와 같다:

T<sub>turnaround</sub> = T<sub>completion</sub> - T<sub>arrival</sub>

(모든 작업은 동시에 도착한다는 교재의 조건을 적용한다면, T<sub>arrival</sub>=0이 될 것이다.)

반환 시간은 **성능** 측면에서의 평가 기준이다. 다른 평가 기준으로 **공정성(fairness)**이 있다. 성능과 공정성은 서로 상충되는 기준인데, 가령 성능을 극대화하기 위해 스케줄러가 몇몇 작업에 실행 기회를 주지 않는 경우, 공정성은 악화될 것이다 (하지만 교재의 말마따나, _인생의 대부분은 완벽하지 않다_). 새로운 평가 항목을 설명하기 전에, 몇 가지 스케줄링 알고리즘을 살펴보겠다.

## 선입선출(First In First Out, FIFO)

단순하고, 구현하기 쉬운 가장 기본적인 알고리즘으로 FIFO가 있다. FIFO는 말 그대로, 가장 먼저 온 프로세스부터 처리하는 알고리즘이다. 예를 들어, 교재의 조건을 적용하여, 작업 실행 시간 10의 작업 A,B,C가 순서대로 도착하였다면, 다음과 같은 방식으로 처리 될 것이다.

```
+-----+-----+-----+         
|     |     |     |         
|     |     |     |         
|  A  |  B  |  C  |         
|     |     |     |         
|     |     |     |         
+-----+-----+-----+-------
0          20          40   
```
     `<그림 1>`

그림 1에서 A는 10, B는 20, C는 30에 종료했다. 세 작업의 평균 반환 시간은 (10+20+30)/3 = 20이 된다.

하지만 교재의 조건 1을 완화하여, 작업의 작업 실행 시간이 모두 같지 않다면 FIFO의 문제는 분명하게 드러나게 된다. 만약 A의 실행시간이 100이고, B와 C의 실행시간이 10이라면, 시스템의 평균 반환 시간은 (100+110+120)/2 = 110이 되어, 좋지 않은 성능을 보여준다. 이렇듯, CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상을 **convoy effedt**라고 부른다.