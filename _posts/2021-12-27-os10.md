---
title: "OSTEP - 가상화: 주소 변환의 원리"
lang: "ko"
layout: post
date: 2021-12-27 15:54:39 +0900
categories: [os]
tags: [os]
---

사실 이번 챕터를 읽으며, 주소 공간의 역할은 대강 이해가 되지만, 주소 공간이 어디에 저장되는지는 조금 헷갈리는 상태이다. 그리고 주소 공간과 가상 주소 공간이 같은 것인지도... 일단 위키백과를 보고 이해한 바로는, 주소 공간은 운영체제가 메모리에 올라가는 각 프로세스에 제공하는 것이며, 주소공간의 크기는 CPU의 주소 버스의 크기에 의해 결정된다고 한다. 메모리의 물리적 주소와 프로그램에서 제시되는 주소값이 서로 다르기에(또한 사용자는 메모리의 물리적 주소를 직접 알 수도 없다) 서로 매핑을 해야만 하며, 이를 CPU의 MMU가 돕는다고 한다. 만약 그렇다면, 주소 공간은 추상화된 개념으로 존재하는 것인가? 아무튼 이는 차차 공부하며 알아봐야겠다.

이전에 **CPU 가상화**를 다루는 방식을 다시 떠올려보면, 프로세스가 시스템 콜을 호출하거나 타이머 인터럽트를 발생시킬 경우 운영체제가 개입하여 하드웨어를 직접 제어하는데, 이를 **제한적 직접 실행(LDE)**기법이라고 말하였다. 메모리 가상화에서도 비슷한 전략이 추구된다고 한다. LDE는 가상화를 제공하는 동시에 효율성(efficiency)과 제어(control)을 모두를 추구하는 기법이며, 효율성을 높이기 위해 하드웨어 지원을 활용한다. 메모리 가상화에는 이에 더해 *유연성(flexibility)* 측면을 다루고자 하며, 이를 바탕으로 하는 메모리 가상화에서 먼저 살펴볼 기법은, **하드웨어 기반 주소 변환(hardware-based address translation)**, 또는 **주소 변환(address translation)**이다. 주소 변환을 통해 **가상 주소(virtual address)**를 정보가 실제 존재하는 **물리 주소(physical address)**로 변환할 수 있다. (물론 이러한 변환이 하드웨어에 기반한다고는 하지만, 보다 정확한 변환을 위해서는 운영체제가 개입을 해야 할 것이다). 메모리 가상화의 목표는 *'프로그램에게 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상'*을 제공하는 것이다.

프로세스의 주소 공간은 다음과 같을 것이다:

```sh
0KB .------------.
1KB |program code|
2KB +------------+
3KB |    heap    |
4KB +------------+
    |	 ...	 |
...
    |			 |
14KB+------------+
15KB| 3000, stack|
16KB.------------.

<그림 1> 프로세스와 그 주소 공간
```
<br />

그리고 프로세스가 아래와 같은 코드를 실행한다고 가정한다(메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 코드):

```c
void func() {
	int x = 3000;
	x = x + 3;	// 우리가 관심 있는 코드
```
<br />

컴파일러는 이 코드를 아래와 같은 어셈블리 코드로 변환할 것이다(x86 어셈블리로 변환한 결과. Mac에서는 `otool`을 사용하여 디스어셈블 할 수 있다).

```assembly
128: movl 0x0(\%ebx), \%eax ; 0+ebx를 eax에 저장
132: addl \$0x03, \%eax		; eax레지스터에 3을 더한다
135: movl \%eax, 0x0(\%ebx)	; eax를 메모리에 다시 저장
```
<br />

어셈블리 코드는 위 <그림 1>에서 프로그램 코드 영역에 순차적을 배치된다. 즉 세 개의 명령어의 코드는 상단 코드 섹션에서 각각 주소 128, 132, 135를 가지고, 변수 x의 값은 주소 15KB에 위치한다(아래 쪽 스택 영역. x의 초기 값 3000이 들어있다). 이 명령어가 실행되면 프로세스의 관점에서 다음과 같은 메모리 접근이 일어날 것이다:
- 주소 128의 명령어를 반입
- 이 명령어 실행(주소 15KB에서 탑재)
- 주소 132의 명령어를 반입
- 이 명령어 실행(메모리 참조 없음)
- 주소 135의 명령어를 반입
- 이 명령어 실행(주소 15KB에 저장)
<br />

위의 <그림 1>을 보면, 프로그램의 관점에서 본 **주소 공간**은 주소 0부터 시작해서 최대 16KB까지이다. 그러나 메모리 가상화를 하기 위해선 운영체제는 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시켜야 한다. (왜냐하면 <그림 2>처럼, 물리 메모리의 첫 번째 슬롯은 운영체제 자신이 사용하고 있기 때문이다.) 즉 프로세스 주소 공간이 실제로는 다른 물리 주소에 배치되어 있음에도, 프로세스에게 주소 0번지부터 시작하는 가상 주소 공간이 주어진듯한 환상을 어떻게 제공할 수 있을까?

```sh
0KB  .------------.
     |     os     |
16KB +------------+
     | free space |
32KB +------------+
     |  프로세스  |
48KB +------------+
     | free space |
64KB .------------.

<그림 2> 하나의 재배치된 프로세스를 가진 물리 메모리
```
<br />

# 동적(하드웨어 기반) 재배치
첫 번째로 실현된 하드웨어 기반 주소 변환은 1950년대 첫 번째 시분할 컴퓨터에서 **베이스와 바운드(base and bound)**, 다른 이름으로는 **동적 재배치(dynamic relocation)**이라는 이름으로 등장하였다. 해당 기법을 구현하기 위해선, 각 CPU마다 2개의 하드웨어 레지스터가 필요한데, 하나는 **베이스(base)** 레지스터라 불리고, 다른 하나는 **바운드(bound)** 레지스터 혹은 **한계(limit)** 레지스터라고 불린다.

작성중...


