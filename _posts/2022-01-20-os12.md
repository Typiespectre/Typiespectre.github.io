---
title: "OSTEP - 가상화: 빈 공간 관리"
lang: "ko"
layout: post
date: 2022-01-20 20:04:30 +0900 
categories: [os]
tags: [os]
---
이번 파트에선 **빈 공간 관리**와 관련된 문제들을 다룬다. 만약 관리하고 있는 메모리 공간이 고정된 크기로 나누어진다면 빈 공간 관리는 쉬울 것이다. 왜냐하면 요청된 공간을 그냥 반환해주면 되기 때문이다. 하지만 **세그멘테이션**으로 물리 메모리를 관리하는 것과 같이, 공간이 *가변 크기*로 나누어지기에 빈 공관 관리와 관련헤서 다양한 문제들이 발생하게 된다. 가변 크기로 공간이 할당되는 경우, 필연적으로 **외부 단편화**가 발생하게 된다. 즉 빈 공간들의 전체 크기가 요청된 공간보다 크더라도, 하나의 연속된 영역이 존재하지 않는다면 요청은 실패하게 된다.
```sh
+----------+----------+----------+
|  unused  |   used   |  unused  |
+----------+----------+----------+
0         10         20         30

# 이 경우, 20바이트의 빈 공간이 있지만, 15바이트의 요청은 실패하게 된다.
```
<br />

(앞으로의 논의는 `malloc()`과 `free()`와 같은 사용자 수준 메모리 할당 라이브러리를 사용하고, 라이브러리는 링크드리스트를 이용하여 힙의 빈 공간을 관리하며, `malloc()`으로 포인터를 받으면, `free()`로 반환하기 전까지 프로그램이 메모리 영역을 소유하기에, **압축**이 불가능한 상황을 가정한다.)

## 저수준 기법들
<br />
1) 분할과 병합

위와 같은 경우의 힙의 빈 공간 리스트가 있다고 가정해보자.
```sh
+----------+----------+----------+
|  unused  |   used   |  unused  |
+----------+----------+----------+
0         10         20         30

# 링크드 리스트
        Address: 0     Address: 20
HEAD -> Length : 10 -> Length : 10 -> NULL
```
<br />

만약 10바이트를 초과하는 요청이 들어온다면, 위와 동일하게 요청은 실패하여 NULL을 반환하게 될 것이다. 하지만 10바이트보다 *적은* 요청일 경우에는 어떻게 될까? 이 경우, 할당기는 **분할(splitting)** 작업을 수행한다.만약 1바이트의 요쳥이 들어온다면, 할당기는 요청을 만족시킬 수 있는 빈 청크를 찾아 이를 둘로 분할하고, 첫 번째 청크는 호출자에게 반환한 후, 두 번째 청크는 리스트에 남겨둔다. 만약 할당기가 리스틑의 두 번쨰 원소를 사용하기로 결정하였다면, `malloc()`은 20(1바이트가 할당된 영역의 주소)을 반환하고, 최종 빈 공간의 리스트는 다음과 같이 표현될 것이다:
```sh
        Address: 0     Address: 21
HEAD -> Length : 10 -> Length : 9  -> NULL

# 할당이 일어나도 기본적인 리스트의 모습은 바뀌지 않았다!
```
<br />

다시 처음의 경우로 돌아가서, 만약 응용 프로그램이 `free(10)`을 호출하여 힙의 중간에 존재하는 공간을 반환한다면, 리스트는 다음과 같이 표현될 것이다. 이 경우 문제는, 힙 전체가 비게 되더라도, 10바이트 길이의 청크 3개로 나누어지기에, 사용자가 20바이트를 요청하는 경우, 실패를 반환하게 된다는 것이다. 이를 해결하기 위해, 할당기는 **병합(coalescing)** 작업을 수행한다. 사용자가 메모리 청크를 반환할 때, 해제되는 청크의 주소와 바로 인접한 빈 청크의 주소를 검사하여, 서로 인접해 있다면 이들을 하나로 병합한다.
```sh
# free(10)
        Address: 10    Address: 0     Address: 20
HEAD -> Length : 10 -> Length : 10 -> Length : 10 -> NULL

# 병합
        Address: 0
HEAD -> Length : 30 -> NULL

# 할당이 한 번도 일어나지 않은 최초의 힙 리스트 모양이 된다!
```
<br />

`free(void *ptr)` 인터페이스는 크기를 `void malloc(size_t size)`와 달리 크기를 매개변수로 받지 않는다. 따라서 대부분의 할당기는 추가 정보를 **헤더(header)** 블럭에 저장한다. 헤더 블럭은 메모리에 유지되며, 보통 해제된 청크 바로 직전에 위치한다. 다음의 경우, 사용자는 `malloc()`을 호출하여 크기 20바이트의 블럭을 요청하고, 그 결과를 `ptr`에 저장하고자 한다. 헤더는 할당된 공간의 크기를 필수적으로 저장해야 한다. 또한 해제 속도를 향상시키기 위해 추가으 피왼터, 무결성 검사를 위한 매직 넘버 그리고 기타 정보들을 저장할 수 있다.
```sh
       +---------------+
       |               | -> malloc 라이브러리에 의해
       |               |    사용되는 헤더
ptr -> +---------------+
       |               |
       |               | -> 호출자에게 반환되는
       |               |    20바이트
       +---------------+

hptr-> +---------------+
       |size:        20|
       |magic:  1234567|
ptr -> +---------------+
       |               |
       |               | -> 호출자에게 반환되는
       |               |    20바이트
       +---------------+
```
<br />

사용자가 `free(ptr)`을 호출하면, 라이브러리는 포인터 연산을 하여 헤더가 가리키는 포인터를 얻어내고, 매직 넘버로 **안전성 검사(sanity check)**를 실시한 뒤, 헤더의 크기를 영역 크기에 합산하여 해제된 영역의 크기를 계산한다. 즉 빈 영역의 크기는 헤더 크기 더하기 사용자에게 할당된 영역의 크기가 된다.
