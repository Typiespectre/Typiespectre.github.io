---
title: "OSTEP - 가상화: 주소 변환의 원리"
lang: "ko"
layout: post
date: 2021-12-27 15:54:39 +0900
categories: [os]
tags: [os]
---

사실 이번 챕터를 읽으며, 주소 공간의 역할은 대강 이해가 되지만, 주소 공간이 어디에 저장되는지는 조금 헷갈리는 상태이다. 그리고 주소 공간과 가상 주소 공간이 같은 것인지도... 일단 위키백과를 보고 이해한 바로는, 주소 공간은 운영체제가 메모리에 올라가는 각 프로세스에 제공하는 것이며, 주소공간의 크기는 CPU의 주소 버스의 크기에 의해 결정된다고 한다. 메모리의 물리적 주소와 프로그램에서 제시되는 주소값이 서로 다르기에(또한 사용자는 메모리의 물리적 주소를 직접 알 수도 없다) 서로 매핑을 해야만 하며, 이를 CPU의 MMU가 돕는다고 한다. 만약 그렇다면, 주소 공간은 추상화된 개념으로 존재하는 것인가? 아무튼 이는 차차 공부하며 알아봐야겠다.

이전에 **CPU 가상화**를 다루는 방식을 다시 떠올려보면, 프로세스가 시스템 콜을 호출하거나 타이머 인터럽트를 발생시킬 경우 운영체제가 개입하여 하드웨어를 직접 제어하는데, 이를 **제한적 직접 실행(LDE)**기법이라고 말하였다. 메모리 가상화에서도 비슷한 전략이 추구된다고 한다. LDE는 가상화를 제공하는 동시에 효율성(efficiency)과 제어(control)을 모두를 추구하는 기법이며, 효율성을 높이기 위해 하드웨어 지원을 활용한다. 메모리 가상화에는 이에 더해 *유연성(flexibility)* 측면을 다루고자 하며, 이를 바탕으로 하는 메모리 가상화에서 먼저 살펴볼 기법은, **하드웨어 기반 주소 변환(hardware-based address translation)**, 또는 **주소 변환(address translation)**이다. 주소 변환을 통해 **가상 주소(virtual address)**를 정보가 실제 존재하는 **물리 주소(physical address)**로 변환할 수 있다. (물론 이러한 변환이 하드웨어에 기반한다고는 하지만, 보다 정확한 변환을 위해서는 운영체제가 개입을 해야 할 것이다). 메모리 가상화의 목표는 *'프로그램에게 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상'*을 제공하는 것이다.